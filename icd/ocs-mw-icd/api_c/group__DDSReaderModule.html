<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTI Data Distribution Service C API: DataReader Support</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>DataReader Support<br>
<small>
[<a class="el" href="group__DDSSubscriptionModule.html">Subscription Module</a>]</small>
</h1><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> entity and associated elements  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReadConditionModule.html">Read Condition Support</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> and associated elements <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSQueryConditionModule.html">Query Condition Support</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> and associated elements <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooDataReader.html">FooDataReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> User data type-specific data reader.  <a href="structFooDataReader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#gga3a218">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a>  <a href="structDDS__RequestedDeadlineMissedStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#gga3a226">DDS_LIVELINESS_CHANGED_STATUS</a>  <a href="structDDS__LivelinessChangedStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#gga3a220">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a>  <a href="structDDS__RequestedIncompatibleQosStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#gga3a221">DDS_SAMPLE_LOST_STATUS</a>  <a href="structDDS__SampleLostStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#gga3a222">DDS_SAMPLE_REJECTED_STATUS</a>  <a href="structDDS__SampleRejectedStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#gga3a228">DDS_SUBSCRIPTION_MATCHED_STATUS</a>  <a href="structDDS__SubscriptionMatchedStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QoS policies supported by a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> entity.  <a href="structDDS__DataReaderQos.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderSeq.html">DDS_DataReaderSeq</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declares IDL <code>sequence</code> &lt; <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> &gt; .  <a href="structDDS__DataReaderSeq.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <a class="el" href="structDDS__Listener.html">DDS_Listener</a> for reader status.  <a href="structDDS__DataReaderListener.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga67">DDS_RequestedDeadlineMissedStatus_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga68">DDS_LivelinessChangedStatus_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga69">DDS_RequestedIncompatibleQosStatus_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga70">DDS_SampleLostStatus_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga71">DDS_SampleRejectedStatus_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga72">DDS_SubscriptionMatchedStatus_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga73">DDS_DataReaderQos_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new QoS instances.  <a href="#ga73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga74">DDS_DataReaderListener_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a>.  <a href="#ga74"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef DDS_DataReaderImpl&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> Allows the application to: (1) declare the data it wishes to receive (i.e. make a subscription) and (2) access the data received by the attached <a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a>.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga1">DDS_DataReaderListener_RequestedDeadlineMissedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> requested_deadline_missed function.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga2">DDS_DataReaderListener_LivelinessChangedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> liveliness_changed function.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga3">DDS_DataReaderListener_RequestedIncompatibleQosCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> requested_incompatible_QoS function.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga4">DDS_DataReaderListener_SampleRejectedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> sample_rejected function.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga5">DDS_DataReaderListener_DataAvailableCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> data_available function.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga6">DDS_DataReaderListener_SubscriptionMatchedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> subscription_match function.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga7">DDS_DataReaderListener_SampleLostCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> subscription_lost function.  <a href="#ga7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga75">DDS_SampleRejectedStatusKind</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a42">DDS_NOT_REJECTED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a43">DDS_REJECTED_BY_INSTANCES_LIMIT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a44">DDS_REJECTED_BY_SAMPLES_LIMIT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a45">DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a46">DDS_REJECTED_BY_REMOTE_WRITERS_LIMIT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a47">DDS_REJECTED_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__DDSReaderModule.html#gga75a48">DDS_REJECTED_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kinds of reasons for rejecting a sample.  <a href="group__DDSReaderModule.html#ga75">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga8">FooDataReader_narrow</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Narrow the given <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> pointer to a <a class="el" href="structFooDataReader.html">FooDataReader</a> pointer.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga9">FooDataReader_as_datareader</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Widen the given <a class="el" href="structFooDataReader.html">FooDataReader</a> pointer to a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> pointer.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a collection of data-samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga13">FooDataReader_take_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to <a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a> except it accesses samples via the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> operation.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga14">FooDataReader_read_next_sample</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFoo.html">Foo</a> *received_data, struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *sample_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga15">FooDataReader_take_next_sample</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFoo.html">Foo</a> *received_data, struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *sample_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *a_handle, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga17">FooDataReader_take_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *a_handle, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga20">FooDataReader_read_next_instance_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>.  <a href="#ga20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga21">FooDataReader_take_next_instance_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>.  <a href="#ga21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> that the application is done accessing the collection of <code>received_data</code> and <code>info_seq</code> obtained by some earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga23">FooDataReader_get_key_value</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, <a class="el" href="structFoo.html">Foo</a> *key_holder, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the instance <code>key</code> that corresponds to an instance <code>handle</code>.  <a href="#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga24">FooDataReader_lookup_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, const <a class="el" href="structFoo.html">Foo</a> *key_holder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the instance <code>handle</code> that corresponds to an instance <code>key_holder</code>.  <a href="#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga25">DDS_RequestedDeadlineMissedStatus_initialize</a> (struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga26">DDS_RequestedDeadlineMissedStatus_copy</a> (struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *self, const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga27">DDS_RequestedDeadlineMissedStatus_finalize</a> (struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga28">DDS_LivelinessChangedStatus_initialize</a> (struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga29">DDS_LivelinessChangedStatus_copy</a> (struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *self, const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga30">DDS_LivelinessChangedStatus_finalize</a> (struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga31">DDS_RequestedIncompatibleQosStatus_initialize</a> (struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga32">DDS_RequestedIncompatibleQosStatus_copy</a> (struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *self, const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> (struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga34">DDS_SampleLostStatus_initialize</a> (struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga35">DDS_SampleLostStatus_copy</a> (struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *self, const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga36">DDS_SampleLostStatus_finalize</a> (struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga37">DDS_SampleRejectedStatus_initialize</a> (struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga38">DDS_SampleRejectedStatus_copy</a> (struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *self, const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga39">DDS_SampleRejectedStatus_finalize</a> (struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga40">DDS_SubscriptionMatchedStatus_initialize</a> (struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga41">DDS_SubscriptionMatchedStatus_copy</a> (struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *self, const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga42">DDS_SubscriptionMatchedStatus_finalize</a> (struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga43">DDS_DataReaderQos_initialize</a> (struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer for new QoS instances.  <a href="#ga43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga44">DDS_DataReaderQos_copy</a> (struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self, const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of the given QoS into this QoS.  <a href="#ga44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga45">DDS_DataReaderQos_finalize</a> (struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any dynamic memory allocated by the policies in this <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a>.  <a href="#ga45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSEntityModule.html#ga0">DDS_Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga46">DDS_DataReader_as_entity</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *dataReader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>'s supertype instance.  <a href="#ga46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga47">DDS_DataReader_create_readcondition</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>.  <a href="#ga47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga48">DDS_DataReader_create_querycondition</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a> instance_states, const char *query_expression, const struct <a class="el" href="structDDS__StringSeq.html">DDS_StringSeq</a> *query_parameters)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<b>Not supported (optional)</b>] Creates a <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a>.  <a href="#ga48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga49">DDS_DataReader_delete_readcondition</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> or <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> attached to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga50">DDS_DataReader_delete_contained_entities</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all the entities that were created by means of the "create" operations on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga51">DDS_DataReader_wait_for_historical_data</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__Duration__t.html">DDS_Duration_t</a> *max_wait)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until all "historical" data is received for <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> entities that have a non-VOLATILE PERSISTENCE Qos kind.  <a href="#ga51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga52">DDS_DataReader_get_matched_publications</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__InstanceHandleSeq.html">DDS_InstanceHandleSeq</a> *publication_handles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the list of publications currently "associated" with this <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga53">DDS_DataReader_get_matched_publication_data</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__PublicationBuiltinTopicData.html">DDS_PublicationBuiltinTopicData</a> *publication_data, const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *publication_handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operation retrieves the information on a publication that is currently "associated" with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga54">DDS_DataReader_get_topicdescription</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#ga54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga55">DDS_DataReader_get_subscriber</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a> to which the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> belongs.  <a href="#ga55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga56">DDS_DataReader_get_sample_rejected_status</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a222">DDS_SAMPLE_REJECTED_STATUS</a> communication status.  <a href="#ga56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga57">DDS_DataReader_get_liveliness_changed_status</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a226">DDS_LIVELINESS_CHANGED_STATUS</a> communication status.  <a href="#ga57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga58">DDS_DataReader_get_requested_deadline_missed_status</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a218">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a> communication status.  <a href="#ga58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga59">DDS_DataReader_get_requested_incompatible_qos_status</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a220">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a> communication status.  <a href="#ga59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga60">DDS_DataReader_get_subscription_matched_status</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a228">DDS_SUBSCRIPTION_MATCHED_STATUS</a> communication status.  <a href="#ga60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga61">DDS_DataReader_get_sample_lost_status</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a221">DDS_SAMPLE_LOST_STATUS</a> communication status.  <a href="#ga61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga62">DDS_DataReader_set_qos</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *qos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the reader QoS.  <a href="#ga62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga63">DDS_DataReader_get_qos</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *qos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the reader QoS.  <a href="#ga63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga64">DDS_DataReader_set_listener</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *l, <a class="el" href="group__DDSStatusTypesModule.html#ga0">DDS_StatusMask</a> mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the reader listener.  <a href="#ga64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga65">DDS_DataReader_get_listener</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the reader listener.  <a href="#ga65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga66">DDS_DataReader_get_listenerX</a> (<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *listener)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;eXtension&gt;&gt;</a></em> Get the reader listener.  <a href="#ga66"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> entity and associated elements 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga67" doxytag="subscription.ifc::DDS_RequestedDeadlineMissedStatus_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_RequestedDeadlineMissedStatus_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any methods. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. <p>
The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSTopicEntityModule.html#ga10">DDS_InconsistentTopicStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga67">DDS_RequestedDeadlineMissedStatus_INITIALIZER</a>; 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga27">DDS_RequestedDeadlineMissedStatus_finalize</a>(&amp;myStatus);                     
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga25">DDS_RequestedDeadlineMissedStatus_initialize</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga27">DDS_RequestedDeadlineMissedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga68" doxytag="subscription.ifc::DDS_LivelinessChangedStatus_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_LivelinessChangedStatus_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function . This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. <p>
The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga30">DDS_LivelinessChangedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga68">DDS_LivelinessChangedStatus_INITIALIZER</a>; 
  ... 
  DDS_LivelinessChangedStatuss_finalize(&amp;myStatus);                     
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga28">DDS_LivelinessChangedStatus_initialize</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga30">DDS_LivelinessChangedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga69" doxytag="subscription.ifc::DDS_RequestedIncompatibleQosStatus_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_RequestedIncompatibleQosStatus_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function . This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. <p>
The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga69">DDS_RequestedIncompatibleQosStatus_INITIALIZER</a>; 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a>(&amp;myStatus);                     
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga31">DDS_RequestedIncompatibleQosStatus_initialize</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga70" doxytag="subscription.ifc::DDS_SampleLostStatus_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_SampleLostStatus_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function . This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. <p>
The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga36">DDS_SampleLostStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga70">DDS_SampleLostStatus_INITIALIZER</a>; 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga36">DDS_SampleLostStatus_finalize</a>(&amp;myStatus);                     
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga34">DDS_SampleLostStatus_initialize</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga36">DDS_SampleLostStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga71" doxytag="subscription.ifc::DDS_SampleRejectedStatus_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_SampleRejectedStatus_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function . This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. <p>
The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga39">DDS_SampleRejectedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga71">DDS_SampleRejectedStatus_INITIALIZER</a>; 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga39">DDS_SampleRejectedStatus_finalize</a>(&amp;myStatus);                     
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga37">DDS_SampleRejectedStatus_initialize</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga39">DDS_SampleRejectedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga72" doxytag="subscription.ifc::DDS_SubscriptionMatchedStatus_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_SubscriptionMatchedStatus_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function . This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. <p>
The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga42">DDS_SubscriptionMatchedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga72">DDS_SubscriptionMatchedStatus_INITIALIZER</a>; 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga42">DDS_SubscriptionMatchedStatus_finalize</a>(&amp;myStatus);                     
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga40">DDS_SubscriptionMatchedStatus_initialize</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga42">DDS_SubscriptionMatchedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga73" doxytag="subscription.ifc::DDS_DataReaderQos_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_DataReaderQos_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new QoS instances. 
<p>
New <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> instances that are stored in the stack should be initialized with this value before they are passed to any function . This step ensures that those contained QoS policies that use dynamic memory are properly initialized. <p>
The simplest way to create a new QoS structure is to initialize it on the stack at the time of its creation: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> myQos = <a class="code" href="group__DDSReaderModule.html#ga73">DDS_DataReaderQos_INITIALIZER</a>;                     
</pre></div> <p>
Note that the above assignment is not a substitute for calling <a class="el" href="group__DDSSubscriberModule.html#ga8">DDS_Subscriber_get_default_datareader_qos</a> or <a class="el" href="group__DDSReaderModule.html#ga63">DDS_DataReader_get_qos</a>; one of those should be called subsequently to setting the QoS of a new or existing entity: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> myQos = <a class="code" href="group__DDSReaderModule.html#ga73">DDS_DataReaderQos_INITIALIZER</a>;
  <a class="code" href="group__DDSSubscriberModule.html#ga8">DDS_Subscriber_get_default_datareader_qos</a>(mySub, &amp;myQos);
  <a class="code" href="group__DDSReaderModule.html#ga63">DDS_DataReader_get_qos</a>(myReader, &amp;myQos);
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga43">DDS_DataReaderQos_initialize</a> <p>
<a class="el" href="group__DDSSubscriberModule.html#ga8">DDS_Subscriber_get_default_datareader_qos</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga45">DDS_DataReaderQos_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga74" doxytag="subscription.ifc::DDS_DataReaderListener_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_DataReaderListener_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a>. 
<p>
All the new instances allocated in the stack should be initialized to this value.No memory is allocated. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="HelloWorld__subscriber_8c-example.html#a51">HelloWorld_subscriber.c</a>.</dl>    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="subscription.ifc::DDS_DataReader"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct DDS_DataReaderImpl <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> Allows the application to: (1) declare the data it wishes to receive (i.e. make a subscription) and (2) access the data received by the attached <a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a>. 
<p>
<dl compact><dt><b>QoS:</b></dt><dd><a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> </dd></dl>
<dl compact><dt><b>Status:</b></dt><dd><a class="el" href="group__DDSStatusTypesModule.html#gga3a224">DDS_DATA_AVAILABLE_STATUS</a>;<br>
 <a class="el" href="group__DDSStatusTypesModule.html#gga3a226">DDS_LIVELINESS_CHANGED_STATUS</a>, <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a>;<br>
 <a class="el" href="group__DDSStatusTypesModule.html#gga3a218">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a>, <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a>;<br>
 <a class="el" href="group__DDSStatusTypesModule.html#gga3a220">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a>, <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a>;<br>
 <a class="el" href="group__DDSStatusTypesModule.html#gga3a221">DDS_SAMPLE_LOST_STATUS</a>, <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a>;<br>
 <a class="el" href="group__DDSStatusTypesModule.html#gga3a222">DDS_SAMPLE_REJECTED_STATUS</a>, <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a>;<br>
 <a class="el" href="group__DDSStatusTypesModule.html#gga3a228">DDS_SUBSCRIPTION_MATCHED_STATUS</a>, ::DDS_SubscriptionMatchedStatus&lt;BR&gt; </dd></dl>
<dl compact><dt><b>Listener:</b></dt><dd><a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> </dd></dl>
A <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> refers to exactly one <a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a> (either a <a class="el" href="group__DDSTopicEntityModule.html#ga1">DDS_Topic</a>, a <a class="el" href="group__DDSTopicEntityModule.html#ga3">DDS_ContentFilteredTopic</a> or a <a class="el" href="group__DDSTopicEntityModule.html#ga7">DDS_MultiTopic</a>) that identifies the data to be read. <p>
The subscription has a unique resulting type. The data-reader may give access to several instances of the resulting type, which can be distinguished from each other by their <code>key</code>. <p>
<a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> is an abstract class. It must be specialised for each particular application data-type (see <a class="el" href="group__DDSUserDataQosModule.html">USER_DATA</a>). The additional methods or functions that must be defined in the auto-generated class for a hypothetical application type <code><a class="el" href="structFoo.html">Foo</a></code> are specified in the generic type <a class="el" href="structFooDataReader.html">FooDataReader</a>. <p>
The following operations may be called even if the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> is not enabled. Other operations will the value <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a> if called on a disabled <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>: <ul>
<li>The base-class operations <a class="el" href="group__DDSReaderModule.html#ga62">DDS_DataReader_set_qos</a>, <a class="el" href="group__DDSReaderModule.html#ga63">DDS_DataReader_get_qos</a>, <a class="el" href="group__DDSReaderModule.html#ga64">DDS_DataReader_set_listener</a>, <a class="el" href="group__DDSReaderModule.html#ga65">DDS_DataReader_get_listener</a>, <a class="el" href="group__DDSEntityModule.html#ga2">DDS_Entity_enable</a>, <a class="el" href="group__DDSEntityModule.html#ga3">DDS_Entity_get_statuscondition</a> and <a class="el" href="group__DDSEntityModule.html#ga4">DDS_Entity_get_status_changes</a> </li>
<li><a class="el" href="group__DDSReaderModule.html#ga57">DDS_DataReader_get_liveliness_changed_status</a> <a class="el" href="group__DDSReaderModule.html#ga58">DDS_DataReader_get_requested_deadline_missed_status</a> <a class="el" href="group__DDSReaderModule.html#ga59">DDS_DataReader_get_requested_incompatible_qos_status</a> <a class="el" href="group__DDSReaderModule.html#ga61">DDS_DataReader_get_sample_lost_status</a> <a class="el" href="group__DDSReaderModule.html#ga56">DDS_DataReader_get_sample_rejected_status</a> <a class="el" href="group__DDSReaderModule.html#ga60">DDS_DataReader_get_subscription_matched_status</a> </li>
</ul>
All sample-accessing operations, namely: <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a>, <a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a>, and <a class="el" href="group__DDSReaderModule.html#ga13">FooDataReader_take_w_condition</a> may return the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> as described in <a class="el" href="group__DDSSubscriberModule.html#ga14">DDS_Subscriber_begin_access</a>. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="HelloWorld__subscriber_8c-example.html#a29">HelloWorld_subscriber.c</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="subscription.ifc::DDS_DataReaderListener_RequestedDeadlineMissedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga1">DDS_DataReaderListener_RequestedDeadlineMissedCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> requested_deadline_missed function. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="subscription.ifc::DDS_DataReaderListener_LivelinessChangedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga2">DDS_DataReaderListener_LivelinessChangedCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> liveliness_changed function. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="subscription.ifc::DDS_DataReaderListener_RequestedIncompatibleQosCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga3">DDS_DataReaderListener_RequestedIncompatibleQosCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> requested_incompatible_QoS function. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="subscription.ifc::DDS_DataReaderListener_SampleRejectedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga4">DDS_DataReaderListener_SampleRejectedCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> sample_rejected function. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="subscription.ifc::DDS_DataReaderListener_DataAvailableCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga5">DDS_DataReaderListener_DataAvailableCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> data_available function. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="subscription.ifc::DDS_DataReaderListener_SubscriptionMatchedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga6">DDS_DataReaderListener_SubscriptionMatchedCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> subscription_match function. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="subscription.ifc::DDS_DataReaderListener_SampleLostCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group__DDSReaderModule.html#ga7">DDS_DataReaderListener_SampleLostCallback</a>)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prototype of a <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> subscription_lost function. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga75" doxytag="subscription.ifc::DDS_SampleRejectedStatusKind"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__DDSReaderModule.html#ga75">DDS_SampleRejectedStatusKind</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Kinds of reasons for rejecting a sample. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga75a42" doxytag="DDS_NOT_REJECTED"></a>DDS_NOT_REJECTED</em>&nbsp;</td><td>
Samples are never rejected. 
<p>
<dl compact><dt><b>See also:</b></dt><dd>ResourceLimitsQosPolicy </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga75a43" doxytag="DDS_REJECTED_BY_INSTANCES_LIMIT"></a>DDS_REJECTED_BY_INSTANCES_LIMIT</em>&nbsp;</td><td>
A resource limit on the number of instances was reached. 
<p>
<dl compact><dt><b>See also:</b></dt><dd>ResourceLimitsQosPolicy </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga75a44" doxytag="DDS_REJECTED_BY_SAMPLES_LIMIT"></a>DDS_REJECTED_BY_SAMPLES_LIMIT</em>&nbsp;</td><td>
A resource limit on the number of samples was reached. 
<p>
<dl compact><dt><b>See also:</b></dt><dd>ResourceLimitsQosPolicy </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga75a45" doxytag="DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT"></a>DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT</em>&nbsp;</td><td>
A resource limit on the number of samples per instance was reached. 
<p>
<dl compact><dt><b>See also:</b></dt><dd>ResourceLimitsQosPolicy </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga75a46" doxytag="DDS_REJECTED_BY_REMOTE_WRITERS_LIMIT"></a>DDS_REJECTED_BY_REMOTE_WRITERS_LIMIT</em>&nbsp;</td><td>
A resource limit on the number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read was reached. 
<p>
This constant is an extension to the DDS standard. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga75a47" doxytag="DDS_REJECTED_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT"></a>DDS_REJECTED_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT</em>&nbsp;</td><td>
A resource limit on the number of remote writers for a single instance from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read was reached. 
<p>
This constant is an extension to the DDS standard. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga75a48" doxytag="DDS_REJECTED_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT"></a>DDS_REJECTED_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT</em>&nbsp;</td><td>
A resource limit on the number of samples from a given remote writer that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store was reached. 
<p>
This constant is an extension to the DDS standard. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga8" doxytag="data.ifc::FooDataReader_narrow"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a>* FooDataReader_narrow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>reader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Narrow the given <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> pointer to a <a class="el" href="structFooDataReader.html">FooDataReader</a> pointer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="data.ifc::FooDataReader_as_datareader"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>* FooDataReader_as_datareader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>reader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Widen the given <a class="el" href="structFooDataReader.html">FooDataReader</a> pointer to a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> pointer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="data.ifc::FooDataReader_read"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation offers the same functionality and API as <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> except that the samples returned remain in the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> such that they can be retrieved again by means of a read or take operation. <p>
Please refer to the documentation of <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take()</a> for details on the number of samples returned within the received_data and info_seq as well as the order in which the samples appear in these sequences. <p>
The act of reading a sample changes its <code>sample_state</code> to <a class="el" href="group__DDSSampleStateModule.html#gga2a49">DDS_READ_SAMPLE_STATE</a>. If the sample belongs to the most recent generation of the instance, it will also set the <code>view_state</code> of the instance to be <a class="el" href="group__DDSViewStateModule.html#gga2a52">DDS_NOT_NEW_VIEW_STATE</a>. It will not affect the <code>instance_state</code> of the instance. <p>
<em>Important:</em> If the samples "returned" by this function are loaned from RTI Data Distribution Service (see <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> for more information on memory loaning), it is important that their contents not be changed. Because the memory in which the data is stored belongs to the middleware, any modifications made to the data will be seen the next time the same samples are read or taken; the samples will no longer reflect the state that was received from the network. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> User data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> A <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>sample_states</code> are returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>view_state</code> are returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching ones of these <code>instance_state</code> are returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a>, <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a>, <a class="el" href="group__DDSReaderModule.html#ga13">FooDataReader_take_w_condition</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="data.ifc::FooDataReader_take"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_take           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a collection of data-samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
The operation will return the list of samples received by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> since the last <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> operation that match the specified <a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>, <a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a> and <a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>. <p>
This operation may fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a1">DDS_RETCODE_ERROR</a> if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o8">DDS_DataReaderResourceLimitsQosPolicy::max_outstanding_reads</a> limit has been exceeded. <p>
The actual number of samples returned depends on the information that has been received by the middleware as well as the <a class="el" href="structDDS__HistoryQosPolicy.html">DDS_HistoryQosPolicy</a>, <a class="el" href="structDDS__ResourceLimitsQosPolicy.html">DDS_ResourceLimitsQosPolicy</a>, <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html">DDS_DataReaderResourceLimitsQosPolicy</a> and the characteristics of the data-type that is associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>: <p>
<ul>
<li>In the case where the <a class="el" href="structDDS__HistoryQosPolicy.html#o0">DDS_HistoryQosPolicy::kind</a> is <a class="el" href="group__DDSHistoryQosModule.html#gga2a311">DDS_KEEP_LAST_HISTORY_QOS</a>, the call will return at most <a class="el" href="structDDS__HistoryQosPolicy.html#o1">DDS_HistoryQosPolicy::depth</a> samples per instance. </li>
</ul>
<ul>
<li>The maximum number of samples returned is limited by <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#o0">DDS_ResourceLimitsQosPolicy::max_samples</a>, and by <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o9">DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_read</a>. </li>
</ul>
<ul>
<li>For multiple instances, the number of samples returned is additionally limited by the product (<a class="el" href="structDDS__ResourceLimitsQosPolicy.html#o2">DDS_ResourceLimitsQosPolicy::max_samples_per_instance</a> * <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#o1">DDS_ResourceLimitsQosPolicy::max_instances</a>) </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o3">DDS_DataReaderResourceLimitsQosPolicy::max_infos</a> is limited, the number of samples returned may also be limited if insufficient <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> resources are available. </li>
</ul>
In the case where the read or take succeeds and the number of samples returned has been limited by means of a maximum limit, as listed above, or insufficient <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> resources, the call will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a0">DDS_RETCODE_OK</a> with those samples the reader is able to return. The user may need to make additional calls, or return outstanding loaned buffers in the case of insuffificient resources, in order to access remaining samples. <p>
Note that in the case where the <a class="el" href="group__DDSTopicEntityModule.html#ga1">DDS_Topic</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> is bound to a data-type that has no key definition, then there will be at most one instance in the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. So the per-sample limits will apply. <p>
The act of <em>taking</em> a sample removes it from RTI Data Distribution Service so it cannot be read or taken again. If the sample belongs to the most recent generation of the instance, it will also set the <code>view_state</code> of the sample's instance to <a class="el" href="group__DDSViewStateModule.html#gga2a52">DDS_NOT_NEW_VIEW_STATE</a>. It will not affect the <code>instance_state</code> of the sample's instance. <p>
After <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> returns, <code>received_data</code> and <code>info_seq</code> will be of the same length and contain the received data. <p>
If the sequences are empty (maximum size equal 0) when the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> is called, the samples returned in the <code>received_data</code> and the corresponding <code>info_seq</code> are 'loaned' to the application from buffers provided by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> . The application can use them as desired and has guaranteed exclusive access to them. <p>
Once the application completes its use of the samples it must 'return the loan' to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> by calling the <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> operation. <p>
<em>Note:</em> While you must call <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> at some point, you do <em>not</em> have to do so before the next <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> call. However, failure to return the loan will eventually deplete the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> of the buffers it needs to receive new samples and eventually samples will start to be lost. The total number of buffers available to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> is specified by the <a class="el" href="structDDS__ResourceLimitsQosPolicy.html">DDS_ResourceLimitsQosPolicy</a> and the <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html">DDS_DataReaderResourceLimitsQosPolicy</a>. <p>
If the sequences are not empty (maximum size not equal 0) when the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> is called, samples are copied to received_data and info_seq. The application will not need to call <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
The order of the samples returned to the caller depends on the <a class="el" href="structDDS__PresentationQosPolicy.html">DDS_PresentationQosPolicy</a>. <p>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#o0">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga2a297">DDS_INSTANCE_PRESENTATION_QOS</a>, the returned collection is a list where samples belonging to the same data instance are consecutive. </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#o0">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga2a298">DDS_TOPIC_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#o2">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>, then returned collection is a list where samples belonging to the same data instance are consecutive. </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#o0">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga2a298">DDS_TOPIC_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#o2">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>, then the returned collection is a list were the relative order of samples is preserved also accross different instances. Note that samples belonging to the same instance may or may not be consecutive. This is because to preserve order it may be necessary to mix samples from different instances. </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#o0">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga2a299">DDS_GROUP_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#o2">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>, then returned collection is a list where samples belonging to the same data instance are consecutive. [<b>Not supported (optional)</b>] </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#o0">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga2a299">DDS_GROUP_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#o2">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>, then the returned collection contains at most one sample. The difference in this case is due to the fact that is required that the application is able to read samples belonging to different <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> objects in a specific order. [<b>Not supported (optional)</b>] </li>
</ul>
In any case, the relative order between the samples of one instance is consistent with the <a class="el" href="group__DDSDestinationOrderQosModule.html">DESTINATION_ORDER</a> policy: <p>
<ul>
<li>If <a class="el" href="structDDS__DestinationOrderQosPolicy.html#o0">DDS_DestinationOrderQosPolicy::kind</a> is <a class="el" href="group__DDSDestinationOrderQosModule.html#gga2a307">DDS_BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</a>, samples belonging to the same instances will appear in the relative order in which there were received (FIFO, earlier samples ahead of the later samples). </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__DestinationOrderQosPolicy.html#o0">DDS_DestinationOrderQosPolicy::kind</a> is <a class="el" href="group__DDSDestinationOrderQosModule.html#gga2a308">DDS_BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS</a>, samples belonging to the same instances will appear in the relative order implied by the <code>source_timestamp</code> (FIFO, smaller values of <code>source_timestamp</code> ahead of the larger values). </li>
</ul>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
In addition to the collection of samples, the read and take operations also use a collection of <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> structures. <h2><a class="anchor" name="Data_and_sampleinfo_sequence">
SEQUENCES USAGE IN TAKE AND READ</a></h2>
The initial (input) properties of the <code>received_data</code> and <code>info_seq</code> collections will determine the precise behavior of the read or take operation. For the purposes of this description, the collections are modeled as having three properties: <ul>
<li>the current-length (<code>len</code>, see <a class="el" href="group__DDSSequenceModule.html#ga3">FooSeq_get_length</a>), </li>
<li>the maximum length (<code>max_len</code>, see <a class="el" href="group__DDSSequenceModule.html#ga1">FooSeq_get_maximum</a>), </li>
<li>and whether the collection container owns the memory of the elements within (<code>owns</code>, see <a class="el" href="group__DDSSequenceModule.html#ga15">FooSeq_has_ownership</a>). </li>
</ul>
The initial values of the <code>len</code>, <code>max_len</code>, and <code>owns</code> properties for the <code>received_data</code> and <code>info_seq</code> collections govern the behavior of the read and take operations as specified by the following rules: <p>
<ol>
<li>
The values of <code>len</code>, <code>max_len</code>, and <code>owns</code> for the two collections must be identical. Otherwise read/take will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. <p>
</li>
<li>
On successful output, the values of <code>len</code>, <code>max_len</code>, and <code>owns</code> will be the same for both collections. <p>
</li>
<li>
If the initial <code>max_len==0</code>, then the <code>received_data</code> and <code>info_seq</code> collections will be filled with elements that are loaned by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. On output, <code>owns</code> will be FALSE, <code>len</code> will be set to the number of values returned, and <code>max_len</code> will be set to a value verifying <code>max_len</code> &gt;= <code>len</code>. The use of this variant allows for zero-copy access to the data and the application will need to return the loan to the <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a> using <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
</li>
<li>
If the initial <code>max_len&gt;0</code> and <code>owns==FALSE</code>, then the read or take operation will fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. This avoids the potential hard-to-detect memory leaks caused by an application forgetting to return the loan. <p>
</li>
<li>
If initial <code>max_len&gt;0</code> and <code>owns==TRUE</code>, then the read or take operation will copy the <code>received_data</code> values and <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> values into the elements already inside the collections. On output, <code>owns</code> will be TRUE, <code>len</code> will be set to the number of values copied, and <code>max_len</code> will remain unchanged. The use of this variant forces a copy but the application can control where the copy is placed and the application will not need to return the loan. The number of samples copied depends on the relative values of <code>max_len</code> and <code>max_samples:</code> <p>
<ul>
<li>
If <code>max_samples</code> == LENGTH_UNLIMITED, then at most <code>max_len</code> values will be copied. The use of this variant lets the application limit the number of samples returned to what the sequence can accommodate. <p>
</li>
<li>
If <code>max_samples</code> &lt;= <code>max_len</code>, then at most <code>max_samples</code> values will be copied. The use of this variant lets the application limit the number of samples returned to fewer that what the sequence can accommodate.  <p>
</li>
<li>
If <code>max_samples</code> &gt; <code>max_len</code>, then the read or take operation will fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. This avoids the potential confusion where the application expects to be able to access up to <code>max_samples</code>, but that number can never be returned, even if they are available in the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, because the output sequence cannot accommodate them. </li>
</ul>
</li>
</ol>
<p>
As described above, upon return the <code>received_data</code> and <code>info_seq</code> collections may contain elements loaned from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. If this is the case, the application will need to use <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> to return the loan once it is no longer using the <code>received_data</code> in the collection. Upon return from <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>, the collection will have <code>max_len=0</code> and <code>owns=FALSE</code>. The application can determine whether it is necessary to return the loan or not based on how the state of the collections when the read/take operation was called, or by accessing the <code>owns</code> property. However, in many cases it may be simpler to always call <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>, as this operation is harmless (i.e. leaves all elements unchanged) if the collection does not have a loan. <p>
To avoid potential memory leaks, the implementation of the <a class="el" href="structFoo.html">Foo</a> and <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> collections should disallow changing the length of a collection for which <code>owns==FALSE</code>. Furthermore, deleting a collection for which <code>owns==FALSE</code> should be considered an error. <p>
On output, the collection of <a class="el" href="structFoo.html">Foo</a> values and the collection of <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> structures are of the same length and are in a one-to-one correspondence. Each <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> provides information, such as the source_timestamp, the sample_state, view_state, and instance_state, etc., about the corresponding sample. <p>
Some elements in the returned collection may not have valid data. If the instance_state in the <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> is <a class="el" href="group__DDSInstanceStateModule.html#gga3a54">DDS_NOT_ALIVE_DISPOSED_INSTANCE_STATE</a> or <a class="el" href="group__DDSInstanceStateModule.html#gga3a55">DDS_NOT_ALIVE_NO_WRITERS_INSTANCE_STATE</a>, then the last sample for that instance in the collection (that is, the one whose <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> has sample_rank==0) does not contain valid data. <p>
Samples that contain no data do not count towards the limits imposed by the <a class="el" href="structDDS__ResourceLimitsQosPolicy.html">DDS_ResourceLimitsQosPolicy</a>. The act of reading/taking a sample sets its sample_state to <a class="el" href="group__DDSSampleStateModule.html#gga2a49">DDS_READ_SAMPLE_STATE</a>. <p>
If the sample belongs to the most recent generation of the instance, it will also set the view_state of the instance to <a class="el" href="group__DDSViewStateModule.html#gga2a52">DDS_NOT_NEW_VIEW_STATE</a>. It will not affect the instance_state of the instance. <p>
This operation must be provided on the specialized class that is generated for the particular application data-type that is being read (<a class="el" href="structFoo.html">Foo</a>). If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
For an example on how <code>take</code> can be used, please refer to the <a class="el" href="group__DDSReaderExampleModule.html#DDSReaderExampleModule_receive">Access received data via a reader</a> "receive example". <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> User data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> A <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>sample_states</code> are returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>view_state</code> are returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>instance_state</code> are returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a>, <a class="el" href="group__DDSReaderModule.html#ga13">FooDataReader_take_w_condition</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="data.ifc::FooDataReader_read_w_condition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_read_w_condition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses via <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>. 
<p>
This operation is especially useful in combination with <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> to filter data samples based on the content. <p>
The specified <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> must be attached to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>; otherwise the operation will fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. <p>
In case the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> is a plain <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> and not the specialized <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a>, the operation is equivalent to calling <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> and passing as <code>sample_states</code>, <code>view_states</code> and <code>instance_states</code> the value of the corresponding attributes in the <code>read_condition</code>. Using this operation, the application can avoid repeating the same parameters specified when creating the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>. <p>
The samples are accessed with the same semantics as <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a>, <a class="el" href="group__DDSReaderModule.html#ga13">FooDataReader_take_w_condition</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="data.ifc::FooDataReader_take_w_condition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_take_w_condition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Analogous to <a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a> except it accesses samples via the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> operation. 
<p>
This operation is analogous to <a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a> except that it accesses samples via the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> operation. <p>
The specified <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> must be attached to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>; otherwise the operation will fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. <p>
The samples are accessed with the same semantics as <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a>. <p>
This operation is especially useful in combination with <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> to filter data samples based on the content. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga12">FooDataReader_read_w_condition</a>, <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="data.ifc::FooDataReader_read_next_sample"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_read_next_sample           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFoo.html">Foo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. This operation also copies the corresponding <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>. The implied order among the samples stored in the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> is the same as for the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation. <p>
The <a class="el" href="group__DDSReaderModule.html#ga14">FooDataReader_read_next_sample</a> operation is semantically equivalent to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation, where the input data sequences has max_len=1, the sample_states=NOT_READ, the view_states=ANY_VIEW_STATE, and the instance_states=ANY_INSTANCE_STATE. <p>
The <a class="el" href="group__DDSReaderModule.html#ga14">FooDataReader_read_next_sample</a> operation provides a simplified API to 'read' samples, avoiding the need for the application to manage sequences and specify states. <p>
If there is no unread data in the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, the operation will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> and nothing is copied. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFoo.html">Foo</a> object where the next received data sample will be returned. The received_data must have been fully allocated. Otherwise, this operation may fail. Must be a valid non-NULL <a class="el" href="structFoo.html">Foo</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_info</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> object where the next received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="data.ifc::FooDataReader_take_next_sample"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_take_next_sample           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFoo.html">Foo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_info</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> and 'removes' it from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> so that it is no longer accessible. This operation also copies the corresponding <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>. This operation is analogous to the <a class="el" href="group__DDSReaderModule.html#ga14">FooDataReader_read_next_sample</a> except for the fact that the sample is removed from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The <a class="el" href="group__DDSReaderModule.html#ga15">FooDataReader_take_next_sample</a> operation is semantically equivalent to the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> operation, where the input data sequences has max_len=1, the sample_states=NOT_READ, the view_states=ANY_VIEW_STATE, and the instance_states=ANY_INSTANCE_STATE. <p>
The <a class="el" href="group__DDSReaderModule.html#ga14">FooDataReader_read_next_sample</a> operation provides a simplified API to 'take' samples, avoiding the need for the application to manage sequences and specify states. <p>
If there is no unread data in the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, the operation will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> and nothing is copied. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFoo.html">Foo</a> object where the next received data sample will be returned. The received_data must have been fully allocated. Otherwise, this operation may fail. Must be a valid non-NULL <a class="el" href="structFoo.html">Foo</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_info</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> object where the next received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="data.ifc::FooDataReader_read_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_read_instance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>a_handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, except that all samples returned belong to the single specified instance whose handle is <code>a_handle</code>. <p>
Upon successful return, the data collection will contain samples all belonging to the same instance. The corresponding <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> verifies <a class="el" href="structDDS__SampleInfo.html#o4">DDS_SampleInfo::instance_handle</a> == <code>a_handle</code>. <p>
The <a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a> operation is semantically equivalent to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation, except in building the collection, the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> will check that the sample belongs to the specified instance and otherwise it will not place the sample in the returned collection. <p>
The behavior of the <a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
This operation may return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if the <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> <code>a_handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The specified instance to return samples for. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if the <code>handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="data.ifc::FooDataReader_take_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_take_instance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>a_handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a>, except for that all samples returned belong to the single specified instance whose handle is <code>a_handle</code>. <p>
The semantics are the same for the <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> operation, except in building the collection, the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> will check that the sample belongs to the specified instance, and otherwise it will not place the sample in the returned collection. <p>
The behavior of the <a class="el" href="group__DDSReaderModule.html#ga17">FooDataReader_take_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga17">FooDataReader_take_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
This operation may return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if the <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> <code>a_handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The specified instance to return samples for. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if the <code>handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="data.ifc::FooDataReader_read_next_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_read_next_instance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> where all the samples belong to a single instance. The behavior is similar to <a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a>, except that the actual instance is not directly specified. Rather, the samples will all belong to the 'next' instance with <code>instance_handle</code> 'greater' than the specified 'previous_handle' that has available samples. <p>
This operation implies the existence of a total order 'greater-than' relationship between the instance handles. The specifics of this relationship are not all important and are implementation specific. The important thing is that, according to the middleware, all instances are ordered relative to each other. This ordering is between the instance handles; It should not depend on the state of the instance (e.g. whether it has data or not) and must be defined even for instance handles that do not correspond to instances currently managed by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. For the purposes of the ordering, it should be 'as if' each instance handle was represented as unique integer. <p>
The behavior of <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> is 'as if' the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> invoked <a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a>, passing the smallest <code>instance_handle</code> among all the ones that: (a) are greater than <code>previous_handle</code>, and (b) have available samples (i.e. samples that meet the constraints imposed by the specified states). <p>
The special value <a class="el" href="group__DDSUserDataModule.html#ga1">DDS_HANDLE_NIL</a> is guaranteed to be 'less than' any valid <code>instance_handle</code>. So the use of the parameter value <code>previous_handle</code> == <a class="el" href="group__DDSUserDataModule.html#ga1">DDS_HANDLE_NIL</a> will return the samples for the instance which has the smallest <code>instance_handle</code> among all the instances that contain available samples. <p>
The operation <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> is intended to be used in an application-driven iteration, where the application starts by passing <code>previous_handle</code> == <a class="el" href="group__DDSUserDataModule.html#ga1">DDS_HANDLE_NIL</a>, examines the samples returned, and then uses the <code>instance_handle</code> returned in the <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> as the value of the <code>previous_handle</code> argument to the next call to <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a>. The iteration continues until <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> returns the value <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
Note that it is possible to call the <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> operation with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. This is because as stated earlier the 'greater-than' relationship is defined even for handles not managed by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. One practical situation where this may occur is when an application is iterating though all the instances, takes all the samples of a <a class="el" href="group__DDSInstanceStateModule.html#gga3a55">DDS_NOT_ALIVE_NO_WRITERS_INSTANCE_STATE</a> instance, returns the loan (at which point the instance information may be removed, and thus the handle becomes invalid), and tries to read the next instance. <p>
The behavior of the <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga16">FooDataReader_read_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previous_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="data.ifc::FooDataReader_take_next_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_take_next_instance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> and 'removes' them from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
This operation has the same behavior as <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a>, except that the samples are 'taken' from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> such that they are no longer accessible via subsequent 'read' or 'take' operations. <p>
Similar to the operation <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a>, it is possible to call <a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The behavior of the <a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previous_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>. The function will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="data.ifc::FooDataReader_read_next_instance_w_condition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_read_next_instance_w_condition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses via <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>. 
<p>
This operation access a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a>, except that all samples returned satisfy the specified condition. In other words, on success, all returned samples belong to the same instance, and the instance is the instance with 'smallest' <code>instance_handle</code> among the ones that verify: (a) <code>instance_handle</code> &gt;= <code>previous_handle</code>, and (b) have samples for which the specified <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> evaluates to TRUE. <p>
Similar to the operation <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a>, it is possible to call <a class="el" href="group__DDSReaderModule.html#ga20">FooDataReader_read_next_instance_w_condition</a> with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The behavior of the <a class="el" href="group__DDSReaderModule.html#ga20">FooDataReader_read_next_instance_w_condition</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga20">FooDataReader_read_next_instance_w_condition</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previous_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="data.ifc::FooDataReader_take_next_instance_w_condition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_take_next_instance_w_condition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses via <a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>. 
<p>
This operation access a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> and 'removes' them from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The operation has the same behavior as <a class="el" href="group__DDSReaderModule.html#ga20">FooDataReader_read_next_instance_w_condition</a>, except that the samples are 'taken' from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> such that they are no longer accessible via subsequent 'read' or 'take' operations. <p>
Similar to the operation <a class="el" href="group__DDSReaderModule.html#ga18">FooDataReader_read_next_instance</a>, it is possible to call <a class="el" href="group__DDSReaderModule.html#ga21">FooDataReader_take_next_instance_w_condition</a> with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The behavior of the <a class="el" href="group__DDSReaderModule.html#ga21">FooDataReader_take_next_instance_w_condition</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga21">FooDataReader_take_next_instance_w_condition</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. <p>
Similar to the <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
If the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> has no samples that meet the constraints, the return value will be <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_samples</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previous_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga13a11">DDS_RETCODE_NO_DATA</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga19">FooDataReader_take_next_instance</a> <p>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="data.ifc::FooDataReader_return_loan"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_return_loan           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>info_seq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicates to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> that the application is done accessing the collection of <code>received_data</code> and <code>info_seq</code> obtained by some earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
This operation indicates to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> that the application is done accessing the collection of <code>received_data</code> and <code>info_seq</code> obtained by some earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The <code>received_data</code> and <code>info_seq</code> must belong to a single related "pair"; that is, they should correspond to a pair returned from a single call to read or take. The <code>received_data</code> and <code>info_seq</code> must also have been obtained from the same <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> to which they are returned. If either of these conditions is not met, the operation will fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. <p>
The operation <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> allows implementations of the read and take operations to "loan" buffers from the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> to the application and in this manner provide "zerocopy" access to the data. During the loan, the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> will guarantee that the data and sample-information are not modified. <p>
It is not necessary for an application to return the loans immediately after the read or take calls. However, as these buffers correspond to internal resources inside the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, the application should not retain them indefinitely. <p>
The use of <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> is only necessary if the read or take calls "loaned" buffers to the application. This only occurs if the <code>received_data</code> and <code>info_Seq</code> collections had <code>max_len=0</code> at the time read or take was called. The application may also examine the "owns" property of the collection to determine where there is an outstanding loan. However, calling <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> on a collection that does not have a loan is safe and has no side effects. <p>
If the collections had a loan, upon return from <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a> the collections will have <code>max_len=0</code>. <p>
Similar to read, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>received_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html">FooSeq</a> object where the received data samples was obtained from earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. Must be a valid non-NULL <a class="el" href="structFooSeq.html">FooSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> object where the received sample info was obtained from earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a>. The function will result in <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="data.ifc::FooDataReader_get_key_value"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> FooDataReader_get_key_value           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFoo.html">Foo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>key_holder</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>handle</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the instance <code>key</code> that corresponds to an instance <code>handle</code>. 
<p>
Useful for keyed data types. <p>
The operation will only fill the fields that form the <code>key</code> inside the <code>key_holder</code> instance. <p>
For keyed data types, this operation may return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if the <code>handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_holder</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a user data type specific key holder, whose <code>key</code> fields are filled by this operation. If <a class="el" href="structFoo.html">Foo</a> has no key, this function has no effect. This function will report the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if <code>key_holder</code> is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <code>instance</code> whose key is to be retrieved. If <a class="el" href="structFoo.html">Foo</a> <em>has</em> a key, <code>handle</code> must represent an existing instance of type <a class="el" href="structFoo.html">Foo</a> known to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. Otherwise, this function will report the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a>. If <a class="el" href="structFoo.html">Foo</a> <em>has</em> a key and <code>handle</code> is <a class="el" href="group__DDSUserDataModule.html#ga1">DDS_HANDLE_NIL</a>, this function will report the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a>. If <a class="el" href="structFoo.html">Foo</a> has a key and <code>handle</code> represents an instance of another type or an instance of type <a class="el" href="structFoo.html">Foo</a> that has been unregistered, this function will report the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a>. If <a class="el" href="structFoo.html">Foo</a> has no key, this function has no effect. This function will report the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a> if <code>handle</code> is NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSWriterModule.html#ga17">FooDataWriter_get_key_value</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga24" doxytag="data.ifc::FooDataReader_lookup_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> FooDataReader_lookup_instance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="structFoo.html">Foo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>key_holder</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the instance <code>handle</code> that corresponds to an instance <code>key_holder</code>. 
<p>
Useful for keyed data types. <p>
This operation takes as a parameter an instance and returns a handle that can be used in subsequent operations that accept an instance handle as an argument. The instance parameter is only used for the purpose of examining the fields that define the key. This operation does not register the instance in question. If the instance has not been previously registered, or if for any other reason the Service is unable to provide an instance handle, the Service will return the special value HANDLE_NIL. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_holder</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> a user data type specific key holder. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the instance handle associated with this instance. If <a class="el" href="structFoo.html">Foo</a> has no key, this function has no effect and returns <a class="el" href="group__DDSUserDataModule.html#ga1">DDS_HANDLE_NIL</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga25" doxytag="subscription.ifc::DDS_RequestedDeadlineMissedStatus_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_RequestedDeadlineMissedStatus_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. <p>
<a class="el" href="group__DDSReaderModule.html#ga27">DDS_RequestedDeadlineMissedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga25">DDS_RequestedDeadlineMissedStatus_initialize</a>(myStatus); 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga27">DDS_RequestedDeadlineMissedStatus_finalize</a>(myStatus);
  free(myStatus);                                         
</pre></div> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga67">DDS_RequestedDeadlineMissedStatus_INITIALIZER</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga27">DDS_RequestedDeadlineMissedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga26" doxytag="subscription.ifc::DDS_RequestedDeadlineMissedStatus_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_RequestedDeadlineMissedStatus_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given status into this status. 
<p>
Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga27" doxytag="subscription.ifc::DDS_RequestedDeadlineMissedStatus_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_RequestedDeadlineMissedStatus_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by status instances. 
<p>
some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga28" doxytag="subscription.ifc::DDS_LivelinessChangedStatus_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_LivelinessChangedStatus_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. <p>
<a class="el" href="group__DDSReaderModule.html#ga30">DDS_LivelinessChangedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga28">DDS_LivelinessChangedStatus_initialize</a>(myStatus); 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga30">DDS_LivelinessChangedStatus_finalize</a>(myStatus);
  free(myStatus);                                         
</pre></div> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga68">DDS_LivelinessChangedStatus_INITIALIZER</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga30">DDS_LivelinessChangedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga29" doxytag="subscription.ifc::DDS_LivelinessChangedStatus_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_LivelinessChangedStatus_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given status into this status. 
<p>
Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga30" doxytag="subscription.ifc::DDS_LivelinessChangedStatus_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_LivelinessChangedStatus_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by status instances. 
<p>
some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga31" doxytag="subscription.ifc::DDS_RequestedIncompatibleQosStatus_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_RequestedIncompatibleQosStatus_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. <p>
<a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga31">DDS_RequestedIncompatibleQosStatus_initialize</a>(myStatus); 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a>(myStatus);
  free(myStatus);                                         
</pre></div> <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga69">DDS_RequestedIncompatibleQosStatus_INITIALIZER</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga32" doxytag="subscription.ifc::DDS_RequestedIncompatibleQosStatus_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_RequestedIncompatibleQosStatus_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given status into this status. 
<p>
Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga33" doxytag="subscription.ifc::DDS_RequestedIncompatibleQosStatus_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_RequestedIncompatibleQosStatus_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by status instances. 
<p>
some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga34" doxytag="subscription.ifc::DDS_SampleLostStatus_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SampleLostStatus_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. <p>
<a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga34">DDS_SampleLostStatus_initialize</a>(myStatus); 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga36">DDS_SampleLostStatus_finalize</a>(myStatus);
  free(myStatus);                                         
</pre></div> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga70">DDS_SampleLostStatus_INITIALIZER</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga36">DDS_SampleLostStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga35" doxytag="subscription.ifc::DDS_SampleLostStatus_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SampleLostStatus_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given status into this status. 
<p>
Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga36" doxytag="subscription.ifc::DDS_SampleLostStatus_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SampleLostStatus_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by status instances. 
<p>
some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga37" doxytag="subscription.ifc::DDS_SampleRejectedStatus_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SampleRejectedStatus_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. <p>
<a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga37">DDS_SampleRejectedStatus_initialize</a>(myStatus); 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga39">DDS_SampleRejectedStatus_finalize</a>(myStatus);
  free(myStatus);                                         
</pre></div> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga71">DDS_SampleRejectedStatus_INITIALIZER</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga39">DDS_SampleRejectedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga38" doxytag="subscription.ifc::DDS_SampleRejectedStatus_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SampleRejectedStatus_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given status into this status. 
<p>
Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga39" doxytag="subscription.ifc::DDS_SampleRejectedStatus_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SampleRejectedStatus_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by status instances. 
<p>
some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga40" doxytag="subscription.ifc::DDS_SubscriptionMatchedStatus_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SubscriptionMatchedStatus_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new status instances. 
<p>
New <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. <p>
<a class="el" href="group__DDSReaderModule.html#ga33">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga40">DDS_SubscriptionMatchedStatus_initialize</a>(myStatus); 
  ... 
  <a class="code" href="group__DDSReaderModule.html#ga42">DDS_SubscriptionMatchedStatus_finalize</a>(myStatus);
  free(myStatus);                                         
</pre></div> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga72">DDS_SubscriptionMatchedStatus_INITIALIZER</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga42">DDS_SubscriptionMatchedStatus_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga41" doxytag="subscription.ifc::DDS_SubscriptionMatchedStatus_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SubscriptionMatchedStatus_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given status into this status. 
<p>
Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga42" doxytag="subscription.ifc::DDS_SubscriptionMatchedStatus_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_SubscriptionMatchedStatus_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by status instances. 
<p>
some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga43" doxytag="subscription.ifc::DDS_DataReaderQos_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReaderQos_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializer for new QoS instances. 
<p>
New <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> instances on heap should be initialized with this function before they are passed to any function . This step ensures that those contained QoS policies that use dynamic memory are properly initialized. This function does not allocate memory. <p>
Calling this function is not a substitute for calling <a class="el" href="group__DDSReaderModule.html#ga63">DDS_DataReader_get_qos</a> or <a class="el" href="group__DDSDomainParticipantModule.html#ga17">DDS_DomainParticipant_get_default_datareader_qos</a>; one of those should be called subsequently to setting the QoS of any new or existing entity. <a class="el" href="group__DDSReaderModule.html#ga45">DDS_DataReaderQos_finalize</a> should be called to free the contained QoS policies that use dynamic memory: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *myQos = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a>)); 
  <a class="code" href="group__DDSReaderModule.html#ga43">DDS_DataReaderQos_initialize</a>(myQos); 
  DDS_DomainParticipantFactory_get_default_datareader_qos(myFactory, myQos);
  DDS_DataReaderQos_set_qos(myDataReader, myQos);
  <a class="code" href="group__DDSReaderModule.html#ga45">DDS_DataReaderQos_finalize</a>(myQos);
  free(myQos);                     
</pre></div> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga73">DDS_DataReaderQos_INITIALIZER</a> <p>
<a class="el" href="group__DDSDomainParticipantModule.html#ga17">DDS_DomainParticipant_get_default_datareader_qos</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga45">DDS_DataReaderQos_finalize</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga44" doxytag="subscription.ifc::DDS_DataReaderQos_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReaderQos_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of the given QoS into this QoS. 
<p>
<a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> instances can use dynamic memory because of the sequences contained in some QoS policies. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga45" doxytag="subscription.ifc::DDS_DataReaderQos_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReaderQos_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free any dynamic memory allocated by the policies in this <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a>. 
<p>
Some QoS policies may use dynamic memory (regardless of whether the QoS itself is in dynamic memory). This function frees that memory but otherwise leaves this QoS unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). <p>
This function does not leave this object in an invalid state. It is permissable to clear a QoS and then subsequently allocate new dynamic memory in one or more of its QoS policies. <p>
Note that if this QoS instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based QoS instance after calling this function . <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga46" doxytag="subscription.ifc::DDS_DataReader_as_entity"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSEntityModule.html#ga0">DDS_Entity</a>* DDS_DataReader_as_entity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dataReader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>'s supertype instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dataReader</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga47" doxytag="subscription.ifc::DDS_DataReader_create_readcondition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>* DDS_DataReader_create_readcondition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>. 
<p>
The returned <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> will be attached and belong to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> sample state of the data samples that are of interest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> view state of the data samples that are of interest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> instance state of the data samples that are of interest </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>return <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> created. Returns NULL in case of failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga48" doxytag="subscription.ifc::DDS_DataReader_create_querycondition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a>* DDS_DataReader_create_querycondition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSSampleStateModule.html#ga0">DDS_SampleStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSViewStateModule.html#ga0">DDS_ViewStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSInstanceStateModule.html#ga0">DDS_InstanceStateMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance_states</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>query_expression</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__StringSeq.html">DDS_StringSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>query_parameters</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
[<b>Not supported (optional)</b>] Creates a <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a>. 
<p>
The returned <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> will be attached and belong to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<a class="el" href="group__DDSQueryAndFilterSyntaxModule.html">Queries and Filters Syntax</a> describes the syntax of <code>query_expression</code> and <code>query_parameters</code>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> sample state of the data samples that are of interest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>view_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> view state of the data samples that are of interest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instance_states</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> instance state of the data samples that are of interest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>query_expression</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Expression for the query. Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>query_parameters</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Parameters for the query expression. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga49" doxytag="subscription.ifc::DDS_DataReader_delete_readcondition"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_delete_readcondition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> or <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> attached to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
Since <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> specializes <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a>, it can also be used to delete a <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a>. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>The <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> must be attached to the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, or the operation will return the error <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Condition to be deleted. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga50" doxytag="subscription.ifc::DDS_DataReader_delete_contained_entities"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_delete_contained_entities           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes all the entities that were created by means of the "create" operations on the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
Deletes all contained <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> and <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> objects. <p>
The operation will return <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> if the any of the contained entities is in a state where it cannot be deleted. <p>
Once <a class="el" href="group__DDSReaderModule.html#ga50">DDS_DataReader_delete_contained_entities</a> returns successfully, the application may delete the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, knowing that it has no contained <a class="el" href="group__DDSReadConditionModule.html#ga0">DDS_ReadCondition</a> and <a class="el" href="group__DDSQueryConditionModule.html#ga0">DDS_QueryCondition</a> objects. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga13a4">DDS_RETCODE_PRECONDITION_NOT_MET</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga51" doxytag="subscription.ifc::DDS_DataReader_wait_for_historical_data"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_wait_for_historical_data           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__Duration__t.html">DDS_Duration_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>max_wait</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Waits until all "historical" data is received for <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> entities that have a non-VOLATILE PERSISTENCE Qos kind. 
<p>
This operation is intended only for <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> entities that have a non-VOLATILE PERSISTENCE QoS kind. <p>
As soon as an application enables a non-VOLATILE <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>, it will start receiving both "historical" data, i.e. the data that was written prior to the time the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> joined the domain, as well as any new data written by the <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a> entities. There are situations where the application logic may require the application to wait until all "historical" data is received. This is the purpose of the <a class="el" href="group__DDSReaderModule.html#ga51">DDS_DataReader_wait_for_historical_data</a> operations. <p>
The operation <a class="el" href="group__DDSReaderModule.html#ga51">DDS_DataReader_wait_for_historical_data</a> blocks the calling thread until either all "historical" data is received, or else duration specified by the max_wait parameter clapses, whichever happens first. A return value of OK indicates that all the "historical" data was "received"; a return value of "TIMEOUT" indicates that max_wait elapsed before all the data was received. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_wait</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Timeout value. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a10">DDS_RETCODE_TIMEOUT</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga52" doxytag="subscription.ifc::DDS_DataReader_get_matched_publications"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_matched_publications           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__InstanceHandleSeq.html">DDS_InstanceHandleSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>publication_handles</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the list of publications currently "associated" with this <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
Matching publications are those in the same domain that have a matching <a class="el" href="group__DDSTopicEntityModule.html#ga1">DDS_Topic</a>, compatible QoS common partition that the <a class="el" href="group__DDSDomainParticipantModule.html#ga4">DDS_DomainParticipant</a> has not indicated should be "ignored" by means of the <a class="el" href="group__DDSDomainParticipantModule.html#ga43">DDS_DomainParticipant_ignore_publication</a> operation. <p>
The handles returned in the <code>publication_handles'</code> list are the ones that are used by the DDS implementation to locally identify the corresponding matched <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a> entities. These handles match the ones that appear in the <code>instance_handle</code> field of the <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> when reading the <a class="el" href="group__DDSPublicationBuiltInTopicModule.html#ga1">DDS_PUBLICATION_TOPIC_NAME</a> builtin topic <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publication_handles</em>&nbsp;</td><td><b>inout</b>. </td></tr>
  </table>
</dl>
The sequence will be grown if the sequence has ownership and the system has the corresponding resources. Use a sequence without ownership to avoid dynamic memory allocation. If the sequence is too small to store all the matches and the system can not resize the sequence, this function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga13a5">DDS_RETCODE_OUT_OF_RESOURCES</a>. <p>
The maximum number of matches possible is configured with <a class="el" href="structDDS__DomainParticipantResourceLimitsQosPolicy.html">DDS_DomainParticipantResourceLimitsQosPolicy</a>. You can use a zero-maximum sequence without ownership to quickly check whether there are any matches without allocating any memory. Cannot be NULL.. <p>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga13a5">DDS_RETCODE_OUT_OF_RESOURCES</a> if the sequence is too small and the system can not resize it, or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga53" doxytag="subscription.ifc::DDS_DataReader_get_matched_publication_data"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_matched_publication_data           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__PublicationBuiltinTopicData.html">DDS_PublicationBuiltinTopicData</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>publication_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group__DDSUserDataModule.html#ga0">DDS_InstanceHandle_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>publication_handle</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This operation retrieves the information on a publication that is currently "associated" with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
Publication with a matching <a class="el" href="group__DDSTopicEntityModule.html#ga1">DDS_Topic</a>, compatible QoS and common partition that the application has not indicated should be "ignored" by means of the <a class="el" href="group__DDSDomainParticipantModule.html#ga43">DDS_DomainParticipant_ignore_publication</a> operation. <p>
The <code>publication_handle</code> must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. Otherwise, the operation will fail and return <a class="el" href="group__DDSReturnTypesModule.html#gga13a3">DDS_RETCODE_BAD_PARAMETER</a>. Use the operation <a class="el" href="group__DDSReaderModule.html#ga52">DDS_DataReader_get_matched_publications</a> to find the publications that are currently matched with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publication_data</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em>. The information to be filled in on the associated publication. Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publication_handle</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Handle to a specific publication associated with the <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a>. Cannot be NULL.. Must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga13a6">DDS_RETCODE_NOT_ENABLED</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga54" doxytag="subscription.ifc::DDS_DataReader_get_topicdescription"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a>* DDS_DataReader_get_topicdescription           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the <a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
Returns that same <a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a> that was used to create the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSTopicEntityModule.html#ga0">DDS_TopicDescription</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga55" doxytag="subscription.ifc::DDS_DataReader_get_subscriber"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a>* DDS_DataReader_get_subscriber           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the <a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a> to which the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> belongs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a> to which the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> belongs. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga56" doxytag="subscription.ifc::DDS_DataReader_get_sample_rejected_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_sample_rejected_status           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a222">DDS_SAMPLE_REJECTED_STATUS</a> communication status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga57" doxytag="subscription.ifc::DDS_DataReader_get_liveliness_changed_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_liveliness_changed_status           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a226">DDS_LIVELINESS_CHANGED_STATUS</a> communication status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga58" doxytag="subscription.ifc::DDS_DataReader_get_requested_deadline_missed_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_requested_deadline_missed_status           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a218">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a> communication status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga59" doxytag="subscription.ifc::DDS_DataReader_get_requested_incompatible_qos_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_requested_incompatible_qos_status           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a220">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a> communication status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga60" doxytag="subscription.ifc::DDS_DataReader_get_subscription_matched_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_subscription_matched_status           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a228">DDS_SUBSCRIPTION_MATCHED_STATUS</a> communication status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga61" doxytag="subscription.ifc::DDS_DataReader_get_sample_lost_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_sample_lost_status           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses the <a class="el" href="group__DDSStatusTypesModule.html#gga3a221">DDS_SAMPLE_LOST_STATUS</a> communication status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga62" doxytag="subscription.ifc::DDS_DataReader_set_qos"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_set_qos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>qos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the reader QoS. 
<p>
This operation modifies the QoS of the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. <p>
The <a class="el" href="structDDS__DataReaderQos.html#o8">DDS_DataReaderQos::user_data</a>, <a class="el" href="structDDS__DataReaderQos.html#o1">DDS_DataReaderQos::deadline</a>, <a class="el" href="structDDS__DataReaderQos.html#o2">DDS_DataReaderQos::latency_budget</a>, <a class="el" href="structDDS__DataReaderQos.html#o10">DDS_DataReaderQos::time_based_filter</a>, <a class="el" href="structDDS__DataReaderQos.html#o11">DDS_DataReaderQos::reader_data_lifecycle</a> can be changed. The other policies are immutable. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qos</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> to be set to. Policies must be consistent. Immutable policies cannot be changed after <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> is enabled. The special value <a class="el" href="group__DDSSubscriberModule.html#ga2">DDS_DATAREADER_QOS_DEFAULT</a> can be used to indicate that the QoS of the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> should be changed to match the current default <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> set in the <a class="el" href="group__DDSSubscriberModule.html#ga0">DDS_Subscriber</a>. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga13a7">DDS_RETCODE_IMMUTABLE_POLICY</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga13a8">DDS_RETCODE_INCONSISTENT_POLICY</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> for rules on consistency among QoS <p>
<a class="el" href="group__DDSEntityModule.html#Entity_set_qos">set_qos (abstract)</a> <p>
<a class="el" href="group__DDSReaderModule.html#ga62">DDS_DataReader_set_qos</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga63" doxytag="subscription.ifc::DDS_DataReader_get_qos"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_qos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>qos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the reader QoS. 
<p>
This function may potentially allocate memory depending on the sequences contained in some QoS policies. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qos</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> The <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> to be filled up. Cannot be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSEntityModule.html#Entity_get_qos">get_qos (abstract)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga64" doxytag="subscription.ifc::DDS_DataReader_set_listener"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_set_listener           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSStatusTypesModule.html#ga0">DDS_StatusMask</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the reader listener. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> to set to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> <a class="el" href="group__DDSStatusTypesModule.html#ga0">DDS_StatusMask</a> associated with the <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a>. The callback function on the listener cannot be NULL if the corresponding status is turned on in the <code>mask</code>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSEntityModule.html#Entity_set_listener">set_listener (abstract)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga65" doxytag="subscription.ifc::DDS_DataReader_get_listener"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> DDS_DataReader_get_listener           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the reader listener. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> of the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga66">DDS_DataReader_get_listenerX</a> <p>
<a class="el" href="group__DDSEntityModule.html#Entity_get_listener">get_listener (abstract)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga66" doxytag="subscription.ifc::DDS_DataReader_get_listenerX"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga13">DDS_ReturnCode_t</a> DDS_DataReader_get_listenerX           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>listener</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;eXtension&gt;&gt;</a></em> Get the reader listener. 
<p>
An alternative form of get_listener that fills in an existing listener structure rather than returning one on the stack. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> structure to be filled up. Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga65">DDS_DataReader_get_listener</a> <p>
<a class="el" href="group__DDSEntityModule.html#Entity_get_listener">get_listener (abstract)</a> </dd></dl>
    </td>
  </tr>
</table>
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Data Distribution Service C API Version 4.2e (General Access Release)</A>
Copyright &copy; 4 Dec 2007 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
