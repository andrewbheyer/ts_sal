<HTML><HEAD><TITLE>LSST - Software ICD  - OCS Middleware</TITLE></HEAD>
<BODY BGCOLOR=White>
<IMG SRC="LSST_logo.gif" ALIGN=LEFT>
<H3><BR>ICD-SW-OCS<BR>
Subsystem : Middleware</H3>
<HR>
<PRE>

</PRE>
<H2>Contents<H2>
<H3>1.0 SCOPE</H3>
<UL>
<H4>            1.1       Document Overview<BR>
		1.2	  Glossary<BR>
            1.3       Applicable Documents</H4>
</UL><H3>2.0       CONCEPT OF OPERATIONS</H3>
<UL>
<H4>            2.1       System Overviews</H4>
<UL>
                        2.1.1       Interface Overview<BR>
</UL><H4>            2.2       Functional Allocation<BR>
            2.3       Data Transfer<BR>
            2.4       Transactions<BR>
            2.5       Security and Integrity</H4>
</UL><H3>3.0       DETAILED INTERFACE REQUIREMENTS</H3>
<UL><H4>            3.1       Commanding Requirements</H4>
<UL>                        3.1.1       Interface Processing Time Requirements<BR>
                        3.1.2       Message Requirements<BR>
</UL><H4>            3.2       Telemetry Requirements<BR>
            3.3       Notifications Requirements<BR>
            3.4       Communication Methods<BR>
            3.5       Security Requirements<BR>
</UL><H3>4.0       QUALIFICATION METHODS<BR>
5.0       NOTES<BR>
6.0       APPENDICES<BR>
7.0       APPROVALS<BR>
8.0       RECORD OF CHANGES</H3>
<HR>
<P>
<H2>1.0 SCOPE</H2>
This Interface Control Document (ICD) specifies the interface(s) between OCS Middleware and other subsystems. Upon formal approval by the line Manager responsible for each participating system, this ICD shall be incorporated into the requirements baseline for each system.
<P>

<H2>            1.1       Document Overview</H2>
The purpose of the ICD is to specify interface requirements to be met by the participating systems. It describes the concept of operations for the interface, defines the message structure and protocols which govern the interchange of data, and identifies the communication paths along which the data is expected to flow.

<H2>1.2 Glossary</H2>
<P><BR>BEE - Back-End Electronic<BR>CALSYS - Camera Calibration System<BR>CCS - Camera Control System<BR>DDS - Data Distribution 
Service<BR>FCS - Filter Controller Subsystem<BR>FEE - Front End Electronics<BR>FPA - Focal Plane Array Actuation<BR>GAS - Guider 
data acquisition system<BR>GS - Guider system<BR>L2U - L2 Controller Unit<BR>LASERCAL - Camera metrology calibration System<BR>LS
ST - Large Synoptic Survey Telescope<BR>OMG - Object Management Group<BR>PWR - Camera Power supply System<BR>QA - Camera Quality 
Assurance measurements<BR>QoS - Quality of Service<BR>RAS - Raft Alignment Subsystem<BR>RTI - Real Time Innovation<BR>SAL - Softw
are Abstraction Layer<BR>SAS - Science Array System<BR>SCU - Shutter Controller Unit<BR>SDS - Science Data Acquisition System<BR>
TC - Thermal Control<BR>TCM - Camera Timing control<BR>VCS - Vacuum Control Subsystem<BR>WDS - Wavefront data acquisition system<
BR>WFS - Wave-front Sensing System<BR>WTCM - Camera wavefront sensors Timing control<<P>

<P>
<H2>            1.3       Applicable Documents</H2><P>
<BR>Datastream Definitions Document - Datastream Prototypes 1.1 (Document-1887)
<BR>Definition of subsystems - LSST Project WBS Dictionary (Document-985)
<BR>Documentation standards - LSST DM UML Modeling Conventions (Document-469)
<BR>Messaging standards - OMG DDS 1.1 (Document-1835)
<BR>Security policies - http://dev.lsstcorp.org/trac/attachment/wiki/Security/Security Policy documents.zip
<BR>Software Abstraction Layer API  - Middleware Software Abstration Layer (Document-3692)
<BR>Software coding standards LSST C++ Programming Style Guidelines (Document-3046)
<BR>Vendor documentation - NDDS manual (Document-2241)
<P>

<H2>2.0       CONCEPT OF OPERATIONS</H2>
<H2>            2.1       System Overview</H2>
<BR>
The publish-subscribe communications model provides a more efficient model for broad data distribution over a network than point-to-point, client-server, and distributed object models. Rather than each node directly addressing other nodes to exchange data, publish-subscribe provides a communications layer that delivers data transparently from the nodes publishing the data to the nodes subscribing to the data.
Publishers send events to the communications layer, which in turn, passes the events to subscribers. In this way, a single event published by a publisher can be sent to multiple subscribers. Events are categorized by topic, and subscribers specify the topics they are interested in. Only events that match a subscribers topic are sent to that subscriber. The service permits selection of a number of quality-of-service criteria to allow applications to choose the appropriate trade-off between reliability and performance.
<P>
The combination of Client-Server and Publish-Subscribe models leads to the concept of Command/Action/Response model, in that the transmission of commands is decoupled from the action that executes that command. A command will return immediately; the action begins in a separate thread. Figure 3 illustrate this model by means of a simplified sequence diagram. When an application receives a command, it validates the attributes associated with that command and immediately accepts or rejects the command. If the command is accepted, the application then initiates an independent internal action to meet the conditions imposed by the command. Once those conditions have been met, an event is posted signifying the successful completion of the action (or the unsuccessful completion if the condition not be met). In this figure, callbacks are implemented using the event features of the publish-subscribe model.
<P>
<IMG SRC="omg.jpg"><P>
Information flows with the aid of the following constructs : Publisher and DataWriter
on the sending side, Subscriber, and DataReader on the receiving side.
<P>
A Publisher is an object responsible for data distribution. It may publish data of
different data types. A DataWriter acts as a typed4 accessor to a publisher. The
DataWriter is the object the application must use to communicate to a publisher the
existence and value of data-objects of a given type. When data-object values have
been communicated to the publisher through the appropriate data-writer, it is the
publisher's responsibility to perform the distribution (the publisher will do this
according to its own QoS, or the QoS attached to the corresponding data-writer). A
publication is defined by the association of a data-writer to a publisher. This
association expresses the intent of the application to publish the data described by
the data-writer in the context provided by the publisher.
<P>
A Subscriber is an object responsible for receiving published data and making it
available (according to the Subscribers QoS) to the receiving application. It may
receive and dispatch data of different specified types. To access the received data,
the application must use a typed DataReader attached to the subscriber. Thus, a
subscription is defined by the association of a data-reader with a subscriber. This
association expresses the intent of the application to subscribe to the data described
by the data-reader in the context provided by the subscriber.
<P>
Topic objects conceptually fit between publications and subscriptions. Publications must
be known in such a way that subscriptions can refer to them unambiguously. A Topic is
meant to fulfill that purpose: it associates a name (unique in the domain), a data-type,
and QoS related to the data itself. In addition to the topic QoS, the QoS of the
DataWriter associated with that Topic and the QoS of the Publisher associated to the
DataWriter control the behavior on the publisher's side, while the corresponding Topic,
DataReader, and Subscriber QoS control the behavior on the subscribers side.
<P>
When an application wishes to publish data of a given type, it must create a Publisher
(or reuse an already created one) and a DataWriter with all the characteristics of the
desired publication. Similarly, when an application wishes to receive data, it must create
a Subscriber (or reuse an already created one) and a DataReader to define the
subscription.
<P>
QoS (Quality of Service) is a general concept that is used to specify the behavior of a
service. Programming service behavior by means of QoS settings offers the advantage
that the application developer only indicates what is wanted rather than how this QoS
should be achieved. Generally speaking, QoS is comprised of several QoS policies. Each
QoS policy is then an independent description that associates a name with a value.
Describing QoS by means of a list of independent QoS policies gives rise to more
flexibility.
<P>
This specification is designed to allow a clear separation between the publish and the
subscribe sides, so that an application process that only participates as a publisher can
embed just what strictly relates to publication. Similarly, an application process that
participates only as a subscriber can embed only what strictly relates to subscription.
<P>
Underlying any data-centric publish subscribe system is a data model. This model
defines the global data space and specifies how Publishers and Subscribers refer to
portions of this space. The data-model can be as simple as a set of unrelated datastructures,
each identified by a topic and a type. The topic provides an identifier that
uniquely identifies some data items within the global data space1. The type provides
structural information needed to tell the middleware how to manipulate the data and also
allows the middleware to provide a level of type safety. However, the target applications
often require a higher-level data model that allows expression of aggregation and
coherence relationships among data elements.
<P>

The OCS Middleware provides multiple levels of access to the functionality
provided. It is recommended that the highest level methods be utilized
whenever possible. <P>
The access levels are : 
<UL>
<LI>SAL (Software abstraction layer)
<LI>OMG DDS 
<LI>OMG RTPS wire protocol support
</UL>

Each subsequent layer provides more detailed access to the low-level details
of the configuration and control of the datastream definitions and/or tuning of
real-time behaviour.



<P>
<BR>
<H3>2.2	SAL (Software abstraction layer)</H3>

The SAL provides the highest level of access to the Middleware functionality.<BR>
Transparent access to telemetry and command objects residing on any<BR>
subsystem is provided via means of automatic shared memory mapping of the <BR>
underlying data objects. The lower level objects are managed using an implementation<BR>
of the OMG's DDS. The currently selected implmentation is RTI NDDS, but the existence
of the SAL permits flexibility in migrating to other DDS solutions if required.
<P>
The SAL provides direct access to only a small subset of the total functionality<BR>
provided by the DDS, reducing both the amount of code required, and it's<BR>
complexity, as seen by the application programmer.
<P>
<P><HR><HR><P>
<H4>Interfaces - C/C++</H4>
<P><PRE>
int svcSAL_initialize ()
</PRE><P>
Initalizes shared memory mapper tables.
<P><HR><P>
<P><PRE>
int svcSAL_connect ( char *name )
</PRE><P>
Connects to object for named topic, returns handle number.
<P><HR><P>
<P><PRE>
int svcSAL_connect1 ( char *name , 
    svcSAL_cachehandle *svcSAL_handle1)
</PRE><P>
Connects to object for named topic, populates handle<BR>
structure with shared memory information.
<P><P><HR><P><PRE>
int svcSAL_commandSHMID ( char *subsys, 
    int *cmdid, 
    int *respid )
</PRE><P>
Returns the shared memory information for the commmand and<BR>
response objects for the named subsystem.
<P><P><HR><P><PRE>
int svcSAL_receiveDatastream (char *subsystem, 
    int timeout, 
    int (*datastreamCallback)(char *subsystem, 
                              void *shmdata_ref ) )
</PRE><P>
Receive an update for a telemetry datastream topic. The call may optionally<BR>
wait on a timeout, wiat forever, or return immediately and issue a<BR>
callback once the next update arrives. 
<P><P><HR><P><PRE>
int svcSAL_receiveCommand (char *subsystem, 
    int timeout, 
    int (*commandCallback)(char *subsystem, 
                           svcSAL_command  *shmcmd_ref, 
                           svcSAL_response *shmresp_ref ) )
</PRE><P>
Receive a command for the named subsystem. The call may optinally<BR>
wait on a timeout, wait forever, or return immediately and issue<BR>
a callback once the next command arrives.
<P><P><HR><P><PRE>
int svcSAL_test_commandCallback (char *subsystem, svcSAL_command *shmcmd_ref, svcSAL_response *shmresp_ref )
</PRE><P>
A minimal implementation of the a command callback routine, <BR>
simply prints the commands to stdout.
<P><HR><P>
<P><PRE>
int svcSAL_test_datastreamCallback (char *subsystem, int *shmdata_ref )
</PRE><P>
A minimal implementation of the a telemetry callback routine, <BR>
simply logs the arrival to stdout.
<P><HR><P>
<P><PRE>
int svcSAL_accessPrivate ( int handle , 
    char *operation, 
    char *revCode , 
    long *sndStamp, 
    long *rcvStamp,
    long *seqNum  , 
    long *origin )
</PRE><P>
Provides access to the consistency checking data embedded in<BR>
every middleware transaction data packet.
<P>
<P><HR><P><PRE>
int svcSAL_accessSync ( int handle , 
    int direction, 
    int optype )
</PRE><P>
Provides access to the synchronization data embedded in<BR>
every middleware transaction data packet.
<P><P><HR><P><PRE>
int svcSAL_shmProperties ( char *name, 
    int *streamid, 
    int *size )
</PRE><P>
Returns the shared memory information for the named topic.
<P><P><HR><P>
In addition to the generic interface, the SAL also includes<BR>
per subsystem/topic specific interfaces. In the descriptions<BR>
which follow, the occurance of <EM>--TOPICID--</EM> can be substituted<BR>
with the name of any legal datastream topic, or subsystem<BR>
command/response topic. For example, <EM>--TOPICID--</EM> might be<BR>
replaced with "tcs_kernel_Target". 
<P><P><HR><P>
<PRE>
GetObject_<EM>--TOPICID--</EM>
</PRE><P>
The GetObject method exists for every topic. It returns the<BR>
handle to the shared memory instantiation. Every item in<BR>
the topic can then be accessed e.g.
<P>
<PRE>
       #include "shmem_tcs_kernel_Target.h"
       shm_tcs_kernel_Target * pshm_tcs_kernel_Target;
       GetObject_tcs_kernel_Target(&pshm_tcs_kernel_Target);
       pshm_tcs_kernel_Target->newValue=999;
       pshm_tcs_kernel_Target->syncO=1;
</PRE>       
<P>	<P><HR><P><PRE>
int svcSAL_activeMQ::<EM>--TOPICID--</EM>_MapMessageSend()
</PRE><P>
The MapMessageSend is provided if ActiveMQ support is selected.<BR>
It publishes the contents of the topic to a corresponding<BR>
ActiveMQ object.
<P><P><HR><P><PRE>
int svcSAL_activeMQ::<EM>--TOPICID--</EM>_MapMessageGet() 
<P></PRE><P>
The MapMessageSend is provided if ActiveMQ support is selected.<BR>
It reteives the latest published value for the topic from a <BR>
corresponding ActiveMQ object.
<P><HR><P>
<P><HR><P>
<P>
<H4>Interfaces - Java</H4>
TBD
<P><P><HR><P>
<P><HR><P>
<H4>Interfaces - Tcl</H4>

The tcl scripting interface provides a quick and easy to use<BR>
testing harness for experimenting with the SAL based <BR>
datastreams and command/response topics.
<P>
The interface is initialized by loading a shared library into<BR>
a standard "wish" command shell.
<P>
The following command will then be available for scripting<BR>
or interactive use
<P><P><HR><P><PRE>
readshm <EM>--TOPICID--</EM>
</PRE><P>
Reads the current values for the topic from the shared<BR>
memory area. Tcl variables with names of the form<BR>
SHM<EM>--TOPICID--</EM>(itename) are populated wit the values.
<P><P><HR><P><PRE>
writeshm <EM>--TOPICID--</EM>
</PRE><P>
Publishes the current values for the topic from Tcl variables<BR>
to the appropriate shared memory area.
<P><P><HR><P><PRE>
sendcmd <EM>--SUBSYSTEM--</EM> args...
</PRE><P>
Send a command to the named subsystem. 
Responses can be received by using the command
readshm --SUBSSYTEM--_response
<P><P><HR><P><PRE>
sendack <EM>--SUBSYSTEM--</EM> args...
</PRE><P>
Send a command response for the named subsystem.
<P><P><HR><P><PRE>
logevent <EM>--SUBSYSTEM--</EM> args...
</PRE><P>
Log an alert/warning/message for the named subsystem.
<P>
<P><HR><P>
<P><HR><P>

<H4>Interfaces - Labview</H4>
<PRE>
int LVcomm_open_SAL(int fd, LStrHandle buf_streamname)
</PRE><P>
Open connection to shared memory for named topic
<P>
<P><HR><P>

<PRE>
int LVcomm_get_i<EM>--TOPICID--</EM>(int fd);
</PRE><P>
Check for incoming topic data.
<P><HR><P>

<PRE>
int LVcomm_send_e<EM>--TOPICID--</EM>(int fd);
</PRE>
Check for outgoing topic update.
<P><HR><P>

<PRE>
int LVcomm_close_<EM>--TOPICID--</EM>(int fd);
</PRE><P>
Shutdown the interface.
<P><P><HR><P>

<PRE>
int LVcomm_get_e<EM>--TOPICID--</EM>(int fd, 
    LStrHandle private_revCode, 
    long* private_sndStamp, 
    long* private_rcvStamp, 
    long* private_seqNum, 
    long* private_origin, 
    long* 
    cmdID, 
    LStrHandle device, 
    LStrHandle operation, 
    LStrHandle value, 
    LStrHandle modifiers);
</PRE>
Retrieve incoming topic data and map to Labview variables.
<P><P><HR><P>

<PRE>
int LVcomm_send_i<EM>--TOPICID--</EM>(int fd, 
    LStrHandle private_revCode, 
    long private_sndStamp,  
    long private_rcvStamp, 
    long private_seqNum,
    long private_origin,
    long cmdID, 
    LStrHandle device,  
    LStrHandle operation, 
    LStrHandle value, 
    LStrHandle modifiers);
</PRE>
Acquire values from Labview variables and publish by updating the <BR>
shared memory object for the topic.<BR>
<P><HR><P>
<P><HR><P>

<H4>Interfaces - Python</H4>
TDB
<P><HR><P>
<P><HR><P>

<H4>Tools - Data definition</H4>

The SAL data definition tasks are instantiated in a virtual<BR>
machine toolset. The VM can be loaded into a VMware or<BR>
VirtualBox session. Once the VM is running, it provides<BR>
a browser based interface. <BR>
<P>
The initial page look like this
<P>
<IMG SRC="vm-reg.gif"><P>

Once the user has registered the VM instance, then data<BR>
definition tasks can be started. review the instructions<BR>
<P>
<IMG SRC="vm-datadef.gif"><P>
then click on the "Datastream Definition Editor".<BR>

The editor page is prepopulated with the default set of <BR>
datastream definitions. For each datastream there are<BR>
3 choices of activity.<BR>
<P>
<IMG SRC="vm-datadef2.gif"><P>
To edit the definition, choose the "Edit contents" option.<BR>
For example, selecting tcs_kernel_Target would open to a page like this<BR>
<P>
<IMG SRC="vm-datadef3.gif"><P>

Here , items can be added, modified, or deleted. Remeber to click<BR>
update (bottom of the page) once all required changes have been <BR>
made.<P>
Once the data definitions have been created the SAL VM will <BR>
generate the corresponding IDL file for input into the<BR>
code generation tools.
<P>
In the event that a pre-existing IDL file has been generated<BR>
then this can also be passed to the SAL VM and syntax checked<BR>
prior to use.
<P>
<A HREF="sampleidl.txt">Sample IDL file defining default Camera datastreams.</A>
 <P>
<P><HR><P>
<H4>Tools - Code generation</H4>

The SAL VM includes the capability to generate implementation<BR>
code for a range of languages. Currently envisioned<BR>
is support for<P>
<UL>
<LI>C/C++ GNU compilers
<LI>Sun Java
<LI>Python
<LI>Tcl
</UL>

The code generated provides interfaces to the following<BR>
packages and environments<P>
<UL>
<LI>RTI DDS
<LI>RTI RTC
<LI>ActiveMQ
<LI>Labview
<LI>ORTE RTPS
<LI>MySQL databases
<LI>EA DDS XML
</UL>

The code generation is selected via the "setup" option <BR>
on the Datastream definiton editor page.<P>
For example, selecting the tcs.kernel.Target "setup" option<BR>
leads to a page like this
<P>
<IMG SRC="vm-codegen1.gif"><P>
<P>
<IMG SRC="vm-codegen2.gif"><P>

In this example , the user has selected to generate code for<BR>
the tcs.kernel.FK5Target item, opting to both publish telemetry<BR>
and process incoming commands.<P>

The generated code will be C/C++ and include support for the <BR>
RTI NDDS low-level software. 
<P>
The code generation process logs it's progress to the browser window,<BR>
and upon sucessfull completion it builds archives containing the <BR>
generated code, and presents a set of links for downloading them.
<P>
<IMG SRC="vm-codegen3.gif"><P>

In this example, downloading and opening the lsst_SAL_c_tcs.tar.gz<BR>
archive
<P>
<IMG SRC="vm-codegen4.gif">
<P>
There are two directories<P>
<UL>
<LI>lsst_SAL_c_tcs - contains application sample code, makefiles, scripts, tests<BR>
<LI>lsstsal.1.0 - contains the libaries supporting the chosen interfaces/environments
</UL>

<P>
<P><HR><P>

<H4>Tools - Simulation</H4>

The SAL VM includes the capability to generate subsystem test<BR>
deployable to multiple machines. It uses scp to copy data and <BR>
programs to the participating machines, so they must be setup with<BR>
the appropriate ssh environment and public-key infrastructure.
<P>
Simulation setup is performed using a form where each datastream<BR>
or commanding participant in a subsystem can be allocated to <BR>
a different computer.<P>
<P>
<IMG SRC="vm-sim1.gif">
<P>
Once the simulation definition has been completed, the VM builds
all the appropriate libararies and test executables. A simulation<BR>
deployment script is created. This script is designed to be run <BR>
from the SAL VM, either by logging in to an ssh terminal session, <BR>
or by connecting to the built-in VNC desktop. For example
<P>
<IMG SRC="vm-sim2.gif">
<P>
shows the VNC desktop with an xterm listing the launcher script<BR>
for a tcs subsystem simulation.
<P><HR><P>
The simulation capabilities also include database creation.<BR>
For each of the defined datastreams and command/response<BR>
streams, the user can select a start and end epoch for the <BR>
simulation, and whether real-time , or a dump to file is<BR>
preferred.<P>
The following example would create an SQL dump file for the<BR>
tcs_kernel_FK5Target datastream, for a 1 hour period.
<P>
<IMG SRC="vm-sim4.gif"><P>
The resulting dump is subsequently presented for download<P>
<IMG SRC="vm-sim5.gif">
<P>
<P><HR><P>

<H4>Tools - Debug</H4>

<P><HR><P>

<H3>2.3	OMG DDS</H3>
The OMG Data-Distribution Service (DDS) is a specification for publish-subscribe data-distribution systems. The purpose of the specification is to provide a common application-level interface that clearly defines the data-distribution service. The specification describes the service using UML, providing a platform-independent model that can then be mapped into a variety of concrete platforms and programming languages.
<P>
The goal of the DDS specification is to facilitate the efficient distribution of data in a distributed system. Participants using DDS can read and write data efficiently and naturally with a typed interface. Underneath, the DDS middleware will distribute the data so that each reading participant can access the most-current values. In effect, the service creates a global data space that any participant can read and write. It also creates a name space to allow participants to find and share objects.
<P>
DDS targets real-time systems; the API and QoS are chosen to balance predictable behavior and implementation efficiency/performance.
<P>
<P><HR><P>

<H4>Interfaces - C/C++</H4>

<A HREF="api_c/classes.html">Generic NDDS C API</A><P>
<A HREF="api_cpp/classes.html">Generic NDDS C++ API</A><P>
<P>

<B>Datastream specific</B>

<PRE>
NDDSUSERDllExport DDS_TypeCode* <EM>--TOPICID--</EM>_get_typecode()

DDS_SEQUENCE(<EM>--TOPICID--</EM>Seq, <EM>--TOPICID--</EM>)
        
NDDSUSERDllExport
RTIBool <EM>--TOPICID--</EM>_initialize(
        <EM>--TOPICID--</EM>* self)
        
NDDSUSERDllExport
RTIBool <EM>--TOPICID--</EM>_initialize_ex(
        <EM>--TOPICID--</EM>* self,RTIBool allocatePointers)

NDDSUSERDllExport
void <EM>--TOPICID--</EM>_finalize(
        <EM>--TOPICID--</EM>* self)
                        
NDDSUSERDllExport
void <EM>--TOPICID--</EM>_finalize_ex(
        <EM>--TOPICID--</EM>* self,RTIBool deletePointers)
        
NDDSUSERDllExport
RTIBool <EM>--TOPICID--</EM>_copy(
        <EM>--TOPICID--</EM>* dst,
        const <EM>--TOPICID--</EM>* src)

RTIBool <EM>--TOPICID--</EM>Plugin_serialize(
    struct RTICdrStream *stream, const <EM>--TOPICID--</EM> *sample,
    void *serialize_option);

RTIBool <EM>--TOPICID--</EM>Plugin_serialize_data(
    struct RTICdrStream *stream, const <EM>--TOPICID--</EM> *sample,
    void *serialize_option);



RTIBool <EM>--TOPICID--</EM>Plugin_deserialize(
    struct RTICdrStream *stream, <EM>--TOPICID--</EM> *sample,
    void *deserialize_option);

RTIBool <EM>--TOPICID--</EM>Plugin_deserialize_data(
    struct RTICdrStream *stream, <EM>--TOPICID--</EM> *sample,
    void *deserialize_option);



unsigned int <EM>--TOPICID--</EM>Plugin_get_max_size_serialized(
    unsigned int current_alignment);

unsigned int <EM>--TOPICID--</EM>Plugin_get_max_size_serialized_data(
    unsigned int current_alignment);

void <EM>--TOPICID--</EM>Plugin_print(
    const <EM>--TOPICID--</EM> *sample,
    const char *description, int indent_level);

<EM>--TOPICID--</EM> *<EM>--TOPICID--</EM>Plugin_create_sample();

<EM>--TOPICID--</EM> *<EM>--TOPICID--</EM>Plugin_create_sample_ex(RTIBool allocatePointers);        

void <EM>--TOPICID--</EM>Plugin_delete_sample(<EM>--TOPICID--</EM> *sample);        

void <EM>--TOPICID--</EM>Plugin_delete_sample_ex(<EM>--TOPICID--</EM> *sample,RTIBool deletePointers);

PRESTypePluginKeyKind <EM>--TOPICID--</EM>Plugin_get_key_kind();

void <EM>--TOPICID--</EM>Plugin_delete(struct PRESTypePlugin *plugin);

void <EM>--TOPICID--</EM>Listener_on_requested_deadline_missed(
    void* listener_data,
    DDS_DataReader* reader,
    const struct DDS_RequestedDeadlineMissedStatus *status)


void <EM>--TOPICID--</EM>Listener_on_requested_incompatible_qos(
    void* listener_data,
    DDS_DataReader* reader,
    const struct DDS_RequestedIncompatibleQosStatus *status)

void <EM>--TOPICID--</EM>Listener_on_sample_rejected(
    void* listener_data,
    DDS_DataReader* reader,
    const struct DDS_SampleRejectedStatus *status)


void <EM>--TOPICID--</EM>Listener_on_liveliness_changed(
    void* listener_data,
    DDS_DataReader* reader,
    const struct DDS_LivelinessChangedStatus *status)

void <EM>--TOPICID--</EM>Listener_on_sample_lost(
    void* listener_data,
    DDS_DataReader* reader,
    const struct DDS_SampleLostStatus *status)

void <EM>--TOPICID--</EM>Listener_on_subscription_matched(
    void* listener_data,
    DDS_DataReader* reader,
    const struct DDS_SubscriptionMatchedStatus *status)

void <EM>--TOPICID--</EM>Listener_on_data_available(
    void* listener_data,
    DDS_DataReader* reader)


 
DDS_TYPESUPPORT_C(<EM>--TOPICID--</EM>TypeSupport, <EM>--TOPICID--</EM>);
DDS_DATAWRITER_C(<EM>--TOPICID--</EM>DataWriter, <EM>--TOPICID--</EM>);
DDS_DATAREADER_C(<EM>--TOPICID--</EM>DataReader, <EM>--TOPICID--</EM>Seq, <EM>--TOPICID--</EM>);
DDS_TYPESUPPORT_CPP(<EM>--TOPICID--</EM>TypeSupport, <EM>--TOPICID--</EM>);
DDS_DATAWRITER_CPP(<EM>--TOPICID--</EM>DataWriter, <EM>--TOPICID--</EM>);
DDS_DATAREADER_CPP(<EM>--TOPICID--</EM>DataReader, <EM>--TOPICID--</EM>Seq, <EM>--TOPICID--</EM>);

 </PRE>
<P><HR><P>

<H4>Interfaces - Java</H4>

<A HREF="api_java/classes.html">Generic NDDS Java API</A>
<P><P>

<B>Datastream specific</B><P>

<B>class <EM>--TOPICID--</EM> </B>
<PRE>
 public <EM>--TOPICID--</EM>(<EM>--TOPICID--</EM> other) 
 public static Object create()
 public boolean equals(Object o) 
 public Object copy_from(Object src)
 public String toString()
 public String toString(String desc, int indent) 
</PRE>


<B>class <EM>--TOPICID--</EM>TypeSupport </B>
<PRE>
 public static String get_type_name() 
 public static void register_type(DomainParticipant participant,
                                     String type_name) 
 public Object copy_sample(Object destination, Object source) 
 public static <EM>--TOPICID--</EM>TypeSupport getInstance()
 public Object create_java_type_instance() 
 public Object create_java_key_instance() 
 public void remember_loaned_info_sequence(Sequence data_sequence,
                                                Sequence info_sequence) 
 public Sequence get_loaned_info_sequence(Sequence data_sequence) 
 public void forget_loaned_info_sequence(Sequence data_sequence) 
 public void serialize_object_data(CdrOutputStream dst, Object src, Object serializeOption)
 public void serialize_object(CdrOutputStream dst, Object src, Object serializeOption)
 public Object deserialize_object_data(Object dst, CdrInputStream src, Object
 serializeOption) 
 public Object deserialize_object(Object dst, CdrInputStream src, Object serializeOption) 
 public int get_max_size_serialized_data(int currentAlignment) 
 public void serialize_object_key(CdrOutputStream dst, Object src, Object serializeOption)
 public Object deserialize_object_key(Object dst, CdrInputStream src, Object serializeOption) 
 public int get_max_size_serialized_key(int currentAlignment) 
 public int get_max_size_serialized(int currentAlignment) 
 public void key_to_instance(Object instance,
                                Object key) 
 public void instance_to_key(Object key,
                                Object instance)
 public boolean instance_to_id(InstanceId_t id,
                                  Object instance)
</PRE>

<B>class <EM>--TOPICID--</EM>DataReader </B>
<PRE>
 public void read(<EM>--TOPICID--</EM>Seq received_data, SampleInfoSeq info_seq,
             int max_samples,
             int sample_states, int view_states, int instance_states) 
 public void take(<EM>--TOPICID--</EM>Seq received_data, SampleInfoSeq info_seq,
             int max_samples,
             int sample_states, int view_states, int instance_states) 
 public void read_w_condition(<EM>--TOPICID--</EM>Seq received_data, 
                 SampleInfoSeq info_seq,
                 int max_samples,
                 ReadCondition condition)
 public void take_w_condition(<EM>--TOPICID--</EM>Seq received_data, 
                 SampleInfoSeq info_seq,
                 int max_samples,
                 ReadCondition condition)
 public void read_next_sample(<EM>--TOPICID--</EM> received_data, SampleInfo sample_info)
 public void take_next_sample(<EM>--TOPICID--</EM> received_data, SampleInfo sample_info)
 public void read_instance(<EM>--TOPICID--</EM>Seq received_data, SampleInfoSeq info_seq,
            int max_samples, InstanceHandle_t a_handle, int sample_states,
            int view_states, int instance_states)
 public void take_instance(<EM>--TOPICID--</EM>Seq received_data, SampleInfoSeq info_seq,
            int max_samples, InstanceHandle_t a_handle, int sample_states,
            int view_states, int instance_states) 
 public void read_next_instance(<EM>--TOPICID--</EM>Seq received_data,
            SampleInfoSeq info_seq, int max_samples,
            InstanceHandle_t a_handle, int sample_states, int view_states,
            int instance_states) 
 public void take_next_instance(<EM>--TOPICID--</EM>Seq received_data,
            SampleInfoSeq info_seq, int max_samples,
            InstanceHandle_t a_handle, int sample_states, int view_states,
            int instance_states) 
 public void read_next_instance_w_condition(<EM>--TOPICID--</EM>Seq received_data,
            SampleInfoSeq info_seq, int max_samples,
            InstanceHandle_t a_handle, ReadCondition condition) 
 public void read_next_instance_w_condition(<EM>--TOPICID--</EM>Seq received_data,
            SampleInfoSeq info_seq, int max_samples,
            InstanceHandle_t a_handle, ReadCondition condition)   
 public void take_next_instance_w_condition(<EM>--TOPICID--</EM>Seq received_data,
            SampleInfoSeq info_seq, int max_samples,
            InstanceHandle_t a_handle, ReadCondition condition) 
 public void return_loan(<EM>--TOPICID--</EM>Seq received_data, SampleInfoSeq info_seq) 
 public void get_key_value(<EM>--TOPICID--</EM> key_holder, InstanceHandle_t handle)
 public instanceHandle_t lookup_instance(<EM>--TOPICID--</EM> key_holder) 

 <EM>--TOPICID--</EM>DataReader(long native_reader, DataReaderListener listener,
                              int mask, TypeSupportImpl data_type)

</PRE>


<B>class <EM>--TOPICID--</EM>DataWriter </B>
<PRE>
 public InstanceHandle_t register_instance(<EM>--TOPICID--</EM> instance_data)
 public InstanceHandle_t register_instance_w_timestamp(<EM>--TOPICID--</EM> instance_data,
                                                 Time_t source_timestamp) 
 public void unregister_instance(<EM>--TOPICID--</EM> instance_data,
                                     InstanceHandle_t handle) 
 public void unregister_instance_w_timestamp(<EM>--TOPICID--</EM> instance_data,
            InstanceHandle_t handle, Time_t source_timestamp) 
 public void write(<EM>--TOPICID--</EM> instance_data, InstanceHandle_t handle)
 public void write_w_timestamp(<EM>--TOPICID--</EM> instance_data,
            InstanceHandle_t handle, Time_t source_timestamp) 
 public void dispose(<EM>--TOPICID--</EM> instance_data, InstanceHandle_t instance_handle)
 public void dispose_w_timestamp(<EM>--TOPICID--</EM> instance_data,
            InstanceHandle_t instance_handle, Time_t source_timestamp) 
 public void get_key_value(<EM>--TOPICID--</EM> key_holder, InstanceHandle_t handle) 
 public InstanceHandle_t lookup_instance(<EM>--TOPICID--</EM> key_holder) 

 <EM>--TOPICID--</EM>DataWriter(long native_writer, DataWriterListener listener,
                              int mask, TypeSupportImpl type) 

</PRE>
<P><HR><P>

<H4>Interfaces - Python</H4>
Currently available within the RTI CEP add-on product.<BR>
Not part of the baseline Middleware stack.
<P><HR><P>

<H4>Tools - Data definition</H4>
<P><HR><P>

<H4>Tools - Code generation</H4>
<P><HR><P>

<H4>Tools - Debug</H4>

<P><HR><P>

<H3>2.4	OMG RTPS wire protocol support</H3>

<H4>Interfaces - C/C++</H4>
<PRE>
ORTEDomainStart(ORTEDomain *d,
    Boolean recvUnicastMetatrafficThread,
    Boolean recvMulticastMetatrafficThread,
    Boolean recvUnicastUserdataThread,
    Boolean recvMulticastUserdataThread,
    Boolean sendThread)

Boolean ORTEDomainPropDefaultGet(ORTEDomainProp *prop)

Boolean ORTEDomainInitEvents(ORTEDomainAppEvents *events)

ORTEDomain * ORTEDomainAppCreate(int domain,
    ORTEDomainProp *prop,
    ORTEDomainAppEvents *events,
    Boolean suspended)

Boolean ORTEDomainAppDestroy(ORTEDomain *d)

Boolean ORTEDomainAppSubscriptionPatternAdd(ORTEDomain *d,
    const char *topic,
    const char *type,
    ORTESubscriptionPatternCallBack subscriptionCallBack, 
    void *param)

Boolean ORTEDomainAppSubscriptionPatternRemove(ORTEDomain *d, 
    const char *topic,
    const char *type)

Boolean  ORTEDomainAppSubscriptionPatternDestroy(ORTEDomain *d) 

ORTEDomain * ORTEDomainMgrCreate(int domain, ORTEDomainProp *prop,
    ORTEDomainAppEvents *events,
    Boolean suspended)

Boolean ORTEDomainMgrDestroy(ORTEDomain *d)

ORTEPublication *  ORTEPublicationCreate(ORTEDomain *d,
    const char *topic, *cstWriter)

int ORTEPublicationDestroy(ORTEPublication,
    const char *typeName,
    void *instance,
    NtpTime *persistence,
    int strength,
    ORTESendCallBack sendCallBack,
    void *sendCallBackParam,
    NtpTime *sendCallBackDelay)

int ORTEPublicationDestroy(ORTEPublication *cstWriter)

ORTEPublicationPropertiesGet(ORTEPublication *cstWriter,ORTEPublProp *pp) 

int ORTEPublicationPropertiesSet(ORTEPublication *cstWriter,ORTEPublProp *pp) 

int ORTEPublicationWaitForSubscriptions(ORTEPublication *cstWriter,
    NtpTime wait)

int ORTEPublicationGetStatus(ORTEPublication *cstWriter,
    ORTEPublStatus *status)				    

int ORTEPublicationGetStatus(ORTEPublication *cstWriter,
    ORTEPublStatus *status)

int ORTEPublicationSend(ORTEPublication *cstWriter)

int ORTEPublicationSendEx(ORTEPublication *cstWriter,
    ORTEPublicationSendParam *psp)

void * ORTEPublicationGetInstance(ORTEPublication *cstWriter)

ORTESubscription *  ORTESubscriptionCreate(ORTEDomain *d,
   SubscriptionMode mode,
   SubscriptionType sType,    
   const char *topic,
   const char *typeName,
   void *instance,
   NtpTime *deadline,
   NtpTime *minimumSeparation,
   ORTERecvCallBack recvCallBack,
   void *recvCallBackParam,
   IPAddress multicastIPAddress)

int ORTESubscriptionDestroy(ORTESubscription *cstReader)

int ORTESubscriptionPropertiesGet(ORTESubscription *cstReader,
    ORTESubsProp *sp)

int ORTESubscriptionPropertiesSet(ORTESubscription *cstReader,
    ORTESubsProp *sp)

int ORTESubscriptionWaitForPublications(ORTESubscription *cstReader,
    NtpTime wait,
    unsigned int retries,
    unsigned int noPublications)

int ORTESubscriptionGetStatus(ORTESubscription *cstReader,
    ORTESubsStatus *status)

int ORTESubscriptionPull(ORTESubscription *cstReader)

void *ORTESubscriptionGetInstance(ORTESubscription *cstReader)

int ORTETypeRegisterAdd(ORTEDomain *d,
    const char *typeName,ORTETypeSerialize ts,
    ORTETypeDeserialize ds,
    ORTETypeGetMaxSize gms,
    unsigned int ms)

int ORTETypeRegisterDestroyAll(ORTEDomain *d)

void ORTEVerbositySetOptions(const char *options)

void ORTEVerbositySetLogFile(const char *logfile)

void ORTEInit(void)

</PRE>
<P><HR><P>

<H4>Interfaces - Java</H4>


<B>class Publication </B>
<PRE>
 public int getHandle()

 public Publication(Domain d, PublProp publProp,  MessageData instance)

 public  boolean destroy()

 public void send(MessageData instance)

 public PublProp getProperties()

 public boolean setProperties(PublProp sp)

 public Status getStatus()

 public int waitForSubscriptions(NtpTime wait, long retries, long noSubscription) 
</PRE>

<B>class Subscription </B>
<PRE>
 public int getHandle()

 public SubsProp getProperties()

 public boolean setProperties(SubsProp sp)

 public Status getStatus()

 public int waitForPublications(NtpTime wait, long retries, long noPublication)

 public boolean pull(int subsHandle) 
</PRE>

<B>class DomainApp </B>
<PRE>
 public DomainApp(int domain, DomainProp ps, DomainEvents ev, boolean suspend)

 public boolean destroy()

 public  boolean regNewDataType(String name, long maxlength)

 public  boolean destroyAllRegTypes()

 public  Subscription createSubscription(SubsProp subsProp,
    MessageData instance, 
    SubscriptionCallback subsCallback)

 public Publication createPublication(PublProp publProp, MessageData instance)
</PRE>

<B>class DomainMgr </B>
<PRE>
 public DomainMgr(int domain,  DomainProp props, DomainEvents events, boolean suspend)
</PRE>
<P><HR><P>

<H4>Tools - Data definition</H4>
<P><HR><P>

<H4>Tools - Code generation</H4>

<P><HR><P>

<H4>Tools - Debug</H4>

<P><HR><P>


<H2>2.5       Security and Integrity</H2>
<BR>
<H4>General policies</H4>

Refer to  http://dev.lsstcorp.org/trac/attachment/wiki/Security/Security Policy documents.zip<P>

<H4>Firewall</H4>
A firewall's basic task is to regulate the flow of traffic between computer networks of different trust levels. Typical examples are the Internet which is a zone with no trust and an internal network which is a zone of higher trust. A zone with an intermediate trust level, situated between the Internet and a trusted internal network, is often referred to as a perimeter network or Demilitarized zone (DMZ).

<H4>Packet filtering</H4>
Packet filters act by inspecting the packets which represent the basic unit of data transfer between computers on the Internet. If a packet matches the packet filter's set of rules, the packet filter will drop (silently discard) the packet, or reject it (discard it, and send error responses to the source).
<P>
This type of packet filtering pays no attention to whether a packet is part of an existing stream of traffic (it stores no information on connection state). Instead, it filters each packet based only on information contained in the packet itself (most commonly using a combination of the packet's source and destination address, its protocol, and, for TCP and UDP traffic, which comprises most internet communication, the port number).
<P>
Because TCP and UDP traffic by convention uses well known ports for particular types of traffic, a stateless packet filter can distinguish between, and thus control, those types of traffic (such as web browsing, remote printing, email transmission, file transfer), unless the machines on each side of the packet filter are both using the same non-standard ports.
Second Generation firewalls do not simply examine the contents of each packet on an individual basis without regard to their placement within the packet series as their predecessors had done, rather they compare some key parts of the trusted database packets. This technology is generally referred to as a 'stateful firewall' as it maintains records of all connections passing through the firewall, and is able to determine whether a packet is the start of a new connection, or part of an existing connection. Though there is still a set of static rules in such a firewall, the state of a connection can in itself be one of the criteria which trigger specific rules.
<P>
This type of firewall can help prevent attacks which exploit existing connections, or certain Denial-of-service attacks, including the SYN flood which sends improper sequences of packets to consume resources on systems behind a firewall.
<P>
<H4>Private subnet</H4>
Firewalls often have network address translation (NAT) functionality, and the hosts protected behind a firewall commonly have addresses in the private address range, as defined in RFC 1918. Firewalls often have such functionality to hide the true address of protected hosts. Originally, the NAT function was developed to address the limited amount of IPv4 routable addresses that could be used or assigned to companies or individuals as well as reduce both the amount and therefore cost of obtaining enough public addresses for every computer in an organization. Hiding the addresses of protected devices has become an increasingly important defense against network reconnaissance.


<H4>NDDS domains</H4>
The domain is the basic construct used to bind
individual applications together for
communication. A distributed application can
elect to use a single domain for all its data-centric
communications. 
<P>
All Data Writers and Data Readers with like data
types will communicate within this domain.
DDS also has the capability to support multiple
domains, thus providing developers a system that
can scale with system needs or segregate based
on different data types. When a specific data
instance is published on one domain, it will not
be received by subscribers residing on any other
domains.
<P>
Multiple domains provide effective data
isolation. One use case would be for a system to
be designed whereby all Command/Control
related data is exchanged via one domain while
Status information is exchanged within another. 
Multiple domains are also a good way to control
the introduction of new functionality into an
existing system.
<P>



<H2>3.0       DETAILED INTERFACE REQUIREMENTS</H2>
<H2>            3.1       Commanding Requirements</H2>
There are two basic classes of commands used :
Lifecycle commands : commands used by OCS to control the lifecycle
characteristics of applications. Users generally do not need to be concerned with the lifecycle commands
because they are implemented by the underlying infrastructure.
<P>
Functional commands : commands that implement the specific functional characteristics of a
subsystem components.
<P>
Functional operation is based on the Command/Action/Response model that isolates the transmission of the
command from the resulting action that is performed. When an application receives a command, it validates any
Configuration associated with that command and immediately accepts or rejects the command. If the command is
accepted, the application then initiates an independent internal action to meet the conditions imposed by the
command. Once those conditions have been met, an event is posted signifying the successful completion of the
action (or the unsuccessful completion if the conditions can not be met).
<P>
Commands return immediately but the actions that are initiated as a result of a command may take some time to
complete. When the action completes, an action status event is posted that includes the completion status of that
action. The subsystem generating the command monitors this status event prior to issuing the command on the
remote system. While the monitoring is performed automatically by the command system, Subsystem developers
may need to attach a callback to perform processing on action completion. This callback may be null if no
processing is needed.
<P>
If a command is accepted by the subsystem it causes an independent action to begin. A response to the
command is returned immediately. The action begins matching the current configuration to the new demand
configuration. When the configurations match (i.e., the subsystem has performed the input operations) the action
signals the successful end of the action. If the configurations cannot be matched (whether by hardware failure,
external stop command, timeout, or some other fault) the action signals the unsuccessful end of the action.
<P>
The important features of the command/action/response model are:
<P>
<UL>
<LI>Commands are never blocked. As soon as one command is started, another one can be issued. The
behavior of the controller when two or more configurations are started can be configured on a
per subsystem basis.
<LI>The actions are performed using one or more separate threads. They can be tuned for priority, number of
simultaneous actions, critical resources, or any other parameters.
<LI>Action completions produce events that tell the state of the current configuration. Actions push the
lifecycle of the configuration through to completion.
<LI>Responses may be monitored by any other subsystems.<P>
</UL><P>


<H4>Generic subsystem control state commands</H4>
<UL>
<TABLE BORDER=3 CELLPADDING=5 BGCOLOR=LightBlue WIDTH=600>
<TR BGCOLOR=yellow><B><TD>Command</TD><TD>Description</TD></B></TR>
<TR><TD>start</TD><TD>Prepare the subsystem to accept functional commands </TD></TR>
<TR><TD>stop</TD><TD>Shutdown functional commanding capabilities </TD></TR>
<TR><TD>pause</TD><TD>Suspend functional activities , internal state is retained</TD></TR>
<TR><TD>resume</TD><TD>Resume functional actitivies (if possible) </TD></TR>
<TR><TD>online</TD><TD>Set subsystem ready for commands</TD></TR>
<TR><TD>offline</TD><TD>Take subsystem offline (must be brought back online before any
other commanding is possible)</TD></TR>
</TABLE>
</UL><P>

<H3>                        3.1.1       Interface Processing Time Requirements</H3>
Command messages issued via the middleware must be received by the computer system(s)
of the commanded subsystem within TDB ms. A preliminary response (ACK) must be issued within
TBD ms and received by the caller within TDB ms of the command origination time.
 
<H3>                        3.1.2       Message Requirements</H3>

Every stream includes items for consistency<BR>
checking and performance monitoring support
<P><UL>
<TABLE BORDER=3 CELLPADDING=5 BGCOLOR=LightBlue WIDTH=600>
<TR BGCOLOR=yellow><B><TD>Identifier</TD><TD>Description</TD></B></TR>
<TR><TD>private_revCode</TD><TD>crc of IDL source</TD></TR>
<TR><TD>private_sndStamp</TD><TD> system time of sender</TD></TR>
<TR><TD>private_rcvStamp</TD><TD>system time of receiver</TD></TR>
<TR><TD>private_seqNum</TD><TD>sequence number (process)</TD></TR>
<TR><TD>private_origin</TD><TD>IP subaddr and PID</TD></TR>
</TABLE>
</UL>
<H2>            3.2       Telemetry Requirements</H2>
Telemetry data issued via the middleware must be received by the computer system(s)
of the Facility database , and any other subscribers , within TDB ms. 
"

set TICD3 "<H2>            3.3       Notifications Requirements</H2>
Any application may
post notifications and/or subscribe to notifications posted elsewhere. The notification service is robust and high performance. A notification consists of a topic and a severity. A sequence of notifications with the same topic is referred to as an event.
<P>
The topic is used to identify publishers to subscribers. The severity may be used as a filter
by notification subscribers.
<P>
The notification service has the following general properties:
An notification topic represents a many to many mapping: notifications may be posted to the topic from more
than one source and received by zero or more targets. (Typically, however, most topics will have
a single source.)
<P>
Notifications posted by a single source into an notification topic are received by all targets in the same order as they were posted.
<P>
Delivery of notifications to one subscriber cannot be blocked by the actions of another subscriber.
An notification stream is an abstract concept: a subscriber may subscribe to an notification stream using a wildcarded name in which case the notifications it receives are the merging of all published notifications whose names match that wildcarded name. 
<P>
Notification are not queued by the service. A late subscriber will not see earlier notifications.
<P>
The service does not drop notifications. A published notification will be delivered to all subscribers.
<P>
The notification service supports arbitrary notification topics.
<P>
Notifications are automatically tagged with the source and a timestamp.

<H2>            3.4       Communication Methods</H3>

<H3>Initiation : NDDS discovery</H3>

The process by which domain participants find out about each others entities
Each participant maintains database on other participants in the domain and their entities
happens automatically behind the scenes (anonymous publish-subscribe) 
<UL>
<LI>Does not cross domain boundaries
<LI>Dynamic discovery
<LI>Participants must refresh their presence in the domain or will be aged out of database
<LI>QoS changes are propagated to remote participants
<LI>Two consecutive phases
<LI>Participant discovery phase
<LI>Participants discover each other
<LI>Best-effort communication
<LI>Endpoint discovery phase 
<LI>Participants exchange information about their datawriter and datareader entities
<LI>Reliable communication
<LI>Steady state traffic to maintain liveliness of participants
<LI>Participants periodically announce their presence using RTPS VAR message
<LI>Contains participant GUID, transport locators, QoS
<LI>Initially sent to all participants in initial peers list, then sent periodically to all discovered participants 
<LI>Sent using best-effort
</UL>

<P>
DataWriter/DataReader discovery 
<UL>
<LI>Send out pub/sub VAR to every new participant
<LI>NACK for pub/sub info if not received from a known participant  
<LI>Send out changes/additions/deletions to each participant
<LI>Uses reliable communication between participants
<LI>Data Distribution Service matches up local and remote entities to establish communication paths
</UL><P>

<IMG SRC="discovery.jpg">
<P>
Discovery is implemented using DDS entities known as Built-in Data Writers and Built-in Data Readers
<UL>
<LI>Uses same infrastructure as user defined Data Writers/Data Readers
<LI>Participant data is sent best effort 
<LI>Publication/subscription data is sent reliably
</UL>
<P>
Three Built-in topics (keyed):
<UL>
<LI>DCPSParticipant
<LI>DCPSPublication
<LI>DCPSSubscription
</UL>
Each participant on the same host and in the same domain requires a unique participant index
<P>
For given domain, participant index determines port numbers used by the participant
<UL><UL><UL>
<PRE>
Unicast meta-traffic:
7400 + ((100 * participant_index) + domain) * 10
Multicast meta-traffic:
7400 + (domain * 10) + 2
Unicast user-traffic:
7400 + (((100 * participant_index) + domain) * 10) + 3
Multicast user-traffic:
7400 + (domain * 10) + 1
</PRE>
</UL></UL></UL>
<P>
<P>
<H3>Flow Control : NDDS topics</H3>

Topics provide the basic connection point
between publishers and subscribers. The Topic of
a given publisher on one node must match the
Topic of an associated subscriber on any other
node. If the Topics do not match, communication
will not take place.
<P>
A Topic is comprised of a Topic Name and a
Topic Type. The Topic Name is a string that
uniquely identifies the Topic within a domain.
The Topic Type is the definition of the data
contained within the Topic. Topics must be
uniquely defined within any one particular
domain. Two Topics with different Topic Names
but the same Topic Type definition would be
considered two different Topics within the DDS
infrastructure.
<P>
<H2>            3.5       Security Requirements</H3>
<H3>Message timestamps</H3>

Message integrity is enhanced by the inclusion of egress-time and
arrival time (local system clocks) field in every topic
(command , notification, and telemetry). The SAL software
automatically performs validation to ensure early
detection of clock slew or other time related problems.

<H3>Software versioning checksums</H3>

Communications consistency and security is supported by the
inclusion of CRC checksum fields in every topic
definition (command , notification, and telemetry).
The SAL software automatically checks that the publisher and
subscribers are running code generated using identical 
(at the source code level) topic definitions. This prevents
problems associated with maintaining consistent inter-subsystem
interfaces across a widely distributed software development
infrastructure.



<H2>4.0       QUALIFICATION METHODS</H2>

<H3>System dictionary</H3>

A systemwide dictionary of all subsystems, devices, 
actions and states is maintained. All the interactions
between subsystems are automatically checked to verify
that only objects defined in the dictionary can be
used or referenced.

<H3>Command definition database</H3>

A database of permissible commands is maintained
on a per subsystem basis. The database references the
system dictonary and contains 1 record per command.
Each command is constrained in terms of target
subsystems, parameter ranges, maximum frequency, 
timeout, pause/hold potential,and failure severity.
<P>
The database is used to automatically generate 
application level code to perform all command
level interactions. This code is thus guaranteed to be
consistent system wide.


<H3>Telemetry datastream Definition database</H3>

All telemetry datastream definitions are stored in a 
database. Each definition is automatically verified
for compliance with the system dictionary. Telemetry
items are detailed in terms of type, size, frequency, 
units, and value ranges. Any item with a physical 
correlate has an SI unit associated with it. 
<P>
The database is used to automatically generate 
application level code to perform all datastream
topic references. This code is thus guaranteed to be
consistent system wide.


<H3>Code generation</H3>
The primary implementation of the software interace described in this
document will be automatically generated. A software abstraction layer
(SAL) provides a standardized wrapper for the low-level OMG DDS 
functionality which provides the transport later. 
<P>
The permissible commands, datastream contents, and issuable alerts are
all defined by the controls system database and their nomenclature is controlled
by the system dictionary. All intersubsystem messages formats are
autogenerated. Low level data transfers include versioning checksums
based on the source level record definition.
<P>
<H3>Testing</H3>
Test servers and clients are generated which implement the full
set of commands, datastreams, and notifications are defined by
the controls system database. Tests may be configured for a 
variable number of servers/clients and automatically monitored
to ensure compliance with bandwidth and latency requirements.
All test results are archived to the facility database for 
future examination.

<H2>5.0       NOTES</H2>

<H2>6.0       APPENDICES</H2>

<H2>7.0       APPROVALS</H2>

<H2>8.0       RECORD OF CHANGES</H2><UL>
<TABLE BORDER=3 CELLPADDING=5 BGCOLOR=LightBlue WIDTH=600>
<TR BGCOLOR=yellow><B><TD>Version</TD><TD>Date</TD><TD>Author</TD><TD>Notes</TD></B></TR>
<TR><TD>1.2</TD><TD>Mar-02-2009</TD><TD>Mills., D.</TD><TD>Initial release</TR>
</TABLE></UL>
<P>

</BODY></HTML>

