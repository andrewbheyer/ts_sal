#!/usr/bin/tclsh
#
# Save-as .xhtml from OpenOffice calc then use this script
# to generate .idl
#

proc parsetable { n it } {
global TABS
   set row 0
   set col 0
   set s [split $it "<>"]
   set ignore 1
   foreach i $s { 
      if { [string range $i 0 7] == "tr class" } {
         incr row 1 ; set col 0 ; set ignore 1
         foreach j "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16" {set TABS($n,$row,$j) ""}
      }
      if { [string range $i 0 2] == "td " } {incr col 1 ; set ignore 1}
#      if { $i == "" || $i == "p" || $i =="/p" || $i == "br/" || $i == "/colgroup"} {set ignore 1}
#      if { $i == "/tr" || $i == "/td"} {set ignore 1}
      if { $i == "/span" || [string range $i 0 4] =="span " || [string range $i 0 3]== "col " } {set ignore 1}
#      if { [string length $i] == 1} { set ignore 1}
#      if { $i == "colgroup" || [string range $i 0 5] == "table " } { set ignore 1}
      if { $i == "/p" } {set ignore 1}
      if { $ignore == 0 } {
         puts stdout "$row,$col = $i"
         set TABS($n,$row,$col) "[set TABS($n,$row,$col)]$i"
      }
      if { $i == "p" } {set ignore 0}
      if { [string range $i 0 14] == "span class=\"T1\"" } {set ignore 0}
    }
}

proc showtab { n r } {
global TABS
  foreach i "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16"  {
     puts stdout "$r,$i = $TABS($n,$r,$i)"
  }
}


set fin [open LSE-130.xhtml.html r]
set fout [open perline w]
set work 0
set tstring ""
while { [gets $fin rec] > -1 } {
  set all [split $rec " "]
  foreach i $all {
     if { [string range [string reverse $i] 0 5] == "elbat<" } {
        incr work 1
        if { $work > 3 } { 
           puts $fout "$tstring </td></tr></table>"
           parsetable $work $tstring
           puts stdout "finished table $work"
        }
        set tstring "<table"
     } else {
        if { $work > 2 } {
           set tstring "$tstring $i"
        }
     }
  }
}
close $fin 
close $fout

set TYPE(2) "short"
set TYPE(4) "long"
set TYPE(6) "long"
foreach u "Volt Volts Pa lps Amp Kelvin Celcius Degrees Radian" {
  set UTYPE($u) float
}

set n 4
while { $n <= $work } {
   puts stdout "Table : $TABS($n,1,1)"
   set row 2
   while { $row < 999 }  {
      if { [info exists TABS($n,$row,2)] } {
         if { [string length $TABS($n,$row,2)] > 0 } {
            set scol 1
            if { [string length $TABS($n,$row,1)] == 0} {set scol 2}
            if { [lindex [split $TABS($n,$row,1) _] 0] == "camera" } {set scol 1}
            if { [lindex [split $TABS($n,$row,1) _] 0] == "Camera" } {set scol 1}
            if { [lindex [split $TABS($n,$row,2) _] 0] == "camera" } {set scol 2}
            if { [lindex [split $TABS($n,$row,2) _] 0] == "Camera" } {set scol 2}
            set topic [string trim $TABS($n,$row,$scol) " 	"]
            set spl [split $topic _]
            set topic [string tolower [lindex $spl 0]]_[join [lrange $spl 1 end] _]
            set shrttopic [string range $topic 7 end]
            if { [info exists F($topic)] == 0 } {
               puts stdout "Topic : $topic"
               set F($topic) [open [set topic].idl w]
               puts $F($topic) "struct $shrttopic \{
  string<32> private_revCode;  //private
  double     private_sndStamp; //private
  double     private_rcvStamp; //private
  long       private_seqNum;   //private
  long       private_origin;   //private"
            }
            set item $TABS($n,$row,[expr $scol+1])
            set desc $TABS($n,$row,[expr $scol+2])
            catch {
              set freq 18
              set freq [expr int(1.0/$TABS($n,$row,[expr $scol+3]))]
            }
            set PUBS($topic) $TABS($n,$row,[expr $scol+4])
            set count $TABS($n,$row,[expr $scol+5])
            if { $count == "??" } {set count 1}
            set size $TABS($n,$row,[expr $scol+6])
            if { $size == "??" } {set size 4}
            set unit $TABS($n,$row,[expr $scol+7])
            if { $size > 8 } {
               set type "string<$size>" 
            } else {
               set type $TYPE($size)
               if { $count > 1 } { set item "$item\[$count\]" }
            }
            if { [info exists UTYPE($unit)] } {set type $UTYPE($unit)}
            puts stdout "  $type	$item;	// $freq | $unit | $desc"
            puts $F($topic) "  $type	$item;	// $freq | $unit | $desc"
         }
      }
      incr row 1
   }
   foreach t [array names F] { 
      if { $PUBS($t) > 1 } {
         puts $F($t) "  unsigned short	REB_ID;	// none | | Raft Electronics Board ID"
      }
      puts $F($t) "\};"
      puts $F($t) "#pragma keylist [string range $t 7 end]"
      close $F($t)
   }
   unset F
   incr n 1
}


foreach component "CCS Cluster Cold Cryo Filter GAS GDS PCMS Prot Purge SAS SDS Thermal WAS WDS" {
  set parts [lsort [glob *$component*.idl]]
  set fout [open sal/sal_camera_$component.idl w]
  puts $fout "module camera"
  puts $fout "\{"
  foreach i $parts {
     set fin [open $i r]
     while { [gets $fin rec] > -1 } {
         puts $fout "	$rec"
     }
     close $fin
  }
  puts $fout "\};"
  close $fout
}


#Run in idl-templates/validated
#
foreach ssys "auxscope calibration dm enclosure environment lasercal m1m3 m2 mount network ocs power scheduler seeing skycam system tcs" {
  set parts [lsort [glob *$ssys*.idl]]
  set fout [open sal/sal_$ssys.idl w]
  puts $fout "module $ssys"
  puts $fout "\{"
  foreach i $parts {
    puts stdout "Processing $i"
    set doneprag 0
    set shrt [join [lrange [split [file rootname $i] _] 1 end] _]
    set fin [open $i r]
    gets $fin rec
    puts $fout "	struct $shrt \{"
    while { [gets $fin rec] > -1 } {
         if { [string range $rec 0 6] == "#pragma"} {
            puts $fout "	#pragma keylist $shrt"
            set doneprag 1
         } else {
            puts $fout "	$rec"
         }
    }
    close $fin
    if { $doneprag == 0 } {
       puts $fout "	#pragma keylist $shrt"
    }
  }
  puts $fout "\};"
  close $fout
  puts stdout "Finished $ssys"
}




