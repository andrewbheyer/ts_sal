<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTI Data Distribution Service C++ API: FooSeq Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>FooSeq Struct Reference<br>
<small>
[<a class="el" href="group__DDSSequenceModule.html">Sequence Support</a>]</small>
</h1><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> IDL <code>sequence<code>&lt;<a class="el" href="structFoo.html">Foo</a>&gt;</code>,</code> a sequence of type <code><a class="el" href="structFoo.html">Foo</a></code>.  
<a href="#_details">More...</a>
<p>
<a href="structFooSeq-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFooSeq.html">FooSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a0">operator=</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;src_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from another sequence, resizing the sequence if necessary.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a1">copy_no_alloc</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;src_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from another sequence, only if the destination sequence has enough capacity.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a2">from_array</a> (const <a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a3">to_array</a> (<a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements to an array of elements. The original contents of the array (if any) are replaced.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a4">operator[]</a> (<a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <code>i-th</code> element of the sequence.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structFoo.html">Foo</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a5">operator[]</a> (<a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <code>i-th</code> element for a <code>const</code> sequence.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a6">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sequence length.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a7">length</a> (<a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the length of this sequence.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a8">ensure_length</a> (<a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> length, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sequence to the desired length, and resize the sequence if necessary.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a9">maximum</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current maximum of the sequence.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a10">maximum</a> (<a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize this sequence to a new desired maximum.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a11">loan_contiguous</a> (<a class="el" href="structFoo.html">Foo</a> *buffer, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loan a contiguous buffer to this sequence.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a12">loan_discontiguous</a> (<a class="el" href="structFoo.html">Foo</a> **buffer, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loan a discontiguous buffer to this sequence.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a13">unloan</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the loaned buffer in the sequence and set the maximum to 0.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a18">has_ownership</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of the owned flag.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a19">~FooSeq</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate this sequence's buffer.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a20">FooSeq</a> (<a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a sequence with the given maximum.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a21">FooSeq</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;foo_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a sequence by copying from an existing sequence.  <a href="#a21"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> IDL <code>sequence<code>&lt;<a class="el" href="structFoo.html">Foo</a>&gt;</code>,</code> a sequence of type <code><a class="el" href="structFoo.html">Foo</a></code>. 
<p>
For any user-data type <code><a class="el" href="structFoo.html">Foo</a></code> that an application defines for the purpose of data-distribution with RTI Data Distribution Service, a <code>FooSeq</code> is generated. The sequence offers a subset of the methods defined by the standard OMG IDL to C++ mapping for sequences. We refer to an IDL <code>sequence<code>&lt;<a class="el" href="structFoo.html">Foo</a>&gt;</code> as</code> <code>FooSeq</code>. <p>
returns the latter. <p>
A new sequence is created for a particular Class, which should not change throughout the lifetime of a sequence instance (although in practice it is not possible to enforce this constraint in an interface). An attempt to add an element to a sequence that is not of the correct element type will result in a ClassCastException. (Note that null is considered to belong to any type.) <p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classFooDataWriter.html">FooDataWriter</a>, <a class="el" href="classFooDataReader.html">FooDataReader</a>, <a class="el" href="classFooTypeSupport.html">FooTypeSupport</a>, <a class="el" href="group__DDSNddsgenModule.html">rtiddsgen</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a19" doxytag="FooSeq::~FooSeq"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">FooSeq::~FooSeq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocate this sequence's buffer. 
<p>
deletes this sequence's <em>buffer</em>, not this sequence itself. To avoid memory leaks, it should be called even on sequences declared on the stack. And after it has been called on a sequence located in dynamic memory, it is still necessary to call free(). <p>
<dl compact><dt><b>Precondition:</b></dt><dd>(owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>). If this precondition is not met, no memory will be freed and an error will be logged. </dd></dl>
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd>maximum == 0 and the underlying buffer is freed. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structFooSeq.html#a9">FooSeq::maximum()</a>, <a class="el" href="structFooSeq.html#a13">FooSeq::unloan</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="FooSeq::FooSeq"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">FooSeq::FooSeq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>new_max</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a sequence with the given maximum. 
<p>
This is a constructor for the sequence. The constructor will automatically allocate memory to hold new_max elements of type <a class="el" href="structFoo.html">Foo</a>. <p>
This constructor will be used when the application creates a sequence using one of the following: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structFooSeq.html">FooSeq</a> mySeq(5);
  <span class="comment">// or</span>
  <a class="code" href="structFooSeq.html">FooSeq</a> mySeq;
  <span class="comment">// or</span>
  <a class="code" href="structFooSeq.html">FooSeq</a>* mySeqPtr = <span class="keyword">new</span> <a class="code" href="structFooSeq.html#a20">FooSeq</a>(5);
</pre></div> <p>
<dl compact><dt><b>Postcondition:</b></dt><dd>maximum == new_max <p>
length == 0 <p>
owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>, </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>Must be &gt;= 0. Otherwise the sequence will be initialized to a new_max=0. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="FooSeq::FooSeq"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">FooSeq::FooSeq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>foo_seq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a sequence by copying from an existing sequence. 
<p>
This is a constructor for the sequence. The constructor will automatically allocate memory to hold foo_seq::maximum() elements of type <a class="el" href="structFoo.html">Foo</a> and will copy the current contents of foo_seq into the new sequence. <p>
This constructor will be used when the application creates a sequence using one of the following: <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structFooSeq.html">FooSeq</a> mySeq(foo_seq);
  <span class="comment">// or</span>
  <a class="code" href="structFooSeq.html">FooSeq</a> mySeq = foo_seq;
  <span class="comment">// or</span>
  <a class="code" href="structFooSeq.html">FooSeq</a> *mySeqPtr = <span class="keyword">new</span> <a class="code" href="structFooSeq.html#a20">FooSeq</a>(foo_seq);
</pre></div> <p>
<dl compact><dt><b>Postcondition:</b></dt><dd>this::maximum == foo_seq::maximum <p>
this::length == foo_seq::length <p>
this[i] == foo_seq[i] for 0 &lt;= i &lt; foo_seq::length <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>If the pre-conditions are not met, the constructor will initilize the new sequence to a maximum of zero. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a0" doxytag="FooSeq::operator="></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structFooSeq.html">FooSeq</a>&amp; FooSeq::operator=           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>src_seq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements from another sequence, resizing the sequence if necessary. 
<p>
This method invokes <a class="el" href="structFooSeq.html#a1">FooSeq::copy_no_alloc</a> after ensuring that the sequence has enough capacity to hold the elements to be copied. <p>
This operator is invoked when the following expression appears in the code: <p>
<div class="fragment"><pre class="fragment"> target_seq = src_seq                     
</pre></div> <p>
<em>Important:</em> This method <em>will</em> allocate memory if this::maximum &lt; src_seq::length. <p>
Therefore, to programatically detect the successful completion of the operator it is recommended that the application first sets the length of this sequence to zero, makes the assignment, and then checks that the length of this sequence matches that of src_seq. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
</dl>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structFooSeq.html#a1">FooSeq::copy_no_alloc</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="FooSeq::copy_no_alloc"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::copy_no_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>src_seq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements from another sequence, only if the destination sequence has enough capacity. 
<p>
Fill the elements in this sequence by copying the corresponding elements in <code>src_seq</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>this::maximum &gt;= src_seq::length <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>this::length == src_seq::length <p>
this[i] == src_seq[i] for 0 &lt;= i &lt; target_seq::length <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the sequence was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>If the pre-conditions are not met, the operator will print a message to stdout and leave this sequence unchanged. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>::FooSeq::operator= </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="FooSeq::from_array"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::from_array           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structFoo.html">Foo</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>array</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced. 
<p>
Fill the elements in this sequence by copying the corresponding elements in <code>array</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>this::length == <code>length</code> <p>
this[i] == array[i] for 0 &lt;= i &lt; <code>length</code> <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be copy elements from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The length of the array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the array was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>If the pre-conditions are not met, the method will print a message to stdout and leave this sequence unchanged. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="FooSeq::to_array"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::to_array           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFoo.html">Foo</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>array</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements to an array of elements. The original contents of the array (if any) are replaced. 
<p>
Copy the elements of this sequence to the corresponding elements in the array. The original contents of the array are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be filled with elements from this sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The number of elements to be copied. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the elements of the sequence were successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="FooSeq::operator[]"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structFoo.html">Foo</a>&amp; FooSeq::operator[]           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <code>i-th</code> element of the sequence. 
<p>
This is the operator that is invoked when the application indexes into a non-const sequence: <p>
<div class="fragment"><pre class="fragment"> myElement = mySequence[i];
  mySequence[i] = myElement;
</pre></div> <p>
Note that a <em>reference</em> to the <code>i-th</code> element is returned (and not a copy). <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="structFooSeq.html#a6">FooSeq::length()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the <code>i-th</code> element </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="FooSeq::operator[]"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="structFoo.html">Foo</a>&amp; FooSeq::operator[]           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <code>i-th</code> element for a <code>const</code> sequence. 
<p>
This is the operator that is invoked when the application indexes into a const sequence: <p>
<div class="fragment"><pre class="fragment"> myElement = mySequence[i];
</pre></div> <p>
Note that a <em>reference</em> to the <code>i-th</code> element is returned (and not a copy). <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="structFooSeq.html#a6">FooSeq::length()</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the <code>i-th</code> element </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="FooSeq::length"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> FooSeq::length           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the sequence length. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the length of the sequence </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="FooSeq::length"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::length           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>new_length</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the length of this sequence. 
<p>
This method does not allocate/deallocate memory. <p>
The new length must not exceed the maximum of this sequence as returned by the <a class="el" href="structFooSeq.html#a9">FooSeq::maximum()</a> operation. (Note that, if necessary, the maximum of this sequence can be increased manually by using the ::FooSeq::maximum(long) operation.) <p>
The elements of the sequence are not modified by this operation. If the new length is larger than the original length, the new elements will be uninitialized; if the length is decreased, the old elements that are beyond the new length will physically remain in the sequence but will not be accessible. <p>
<dl compact><dt><b>Postcondition:</b></dt><dd>length = new_length. </dd></dl>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_length</em>&nbsp;</td><td>the new desired length. This value must be non-negative and cannot exceed maximum of the sequence. In other words 0 &lt;= new_length &lt;= maximum </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> on sucess or <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="FooSeq::ensure_length"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::ensure_length           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the sequence to the desired length, and resize the sequence if necessary. 
<p>
If the current maximum is greater than the desired length, then sequence is not resized. <p>
Otherwise if this sequence owns its buffer, the sequence is resized to the new maximum by freeing and re-allocating the buffer. However, if the sequence does not own its buffer, this operation will fail. <p>
This function allows user to avoid unnecessary buffer re-allocation. <p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>length</code> &lt;= <code>max</code> <p>
owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if sequence needs to be resized </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>length == <code>length</code> <p>
maximum == <code>max</code> if resized </dd></dl>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The new length that should be set. Must be &gt;= 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> If sequence need to be resized, this is the maximum that should be set. <code>max</code> &gt;= <code>length</code> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="FooSeq::maximum"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> FooSeq::maximum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current maximum of the sequence. 
<p>
The <code>maximum</code> of the sequence represents the maximum number of elements that the underlying buffer can hold. It does not represent the current number of elements. <p>
The <code>maximum</code> is a non-negative number. It is initialized when the sequence is first created and can only be changed by mean of the ::FooSeq::maximum(long) operation. <p>
<dl compact><dt><b>Returns:</b></dt><dd>the current maximum of the sequence. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structFooSeq.html#a6">FooSeq::length()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="FooSeq::maximum"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::maximum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>new_max</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resize this sequence to a new desired maximum. 
<p>
This operation does nothing if the new desired maximum matches the current maximum. <p>
If this sequence owns its buffer and the new maximum is not equal to the old maximum, then the existing buffer will be freed and re-allocated. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> <p>
length == MINIMUM(original length, new_max) </dd></dl>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>Must be &gt;= 0. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="FooSeq::loan_contiguous"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::loan_contiguous           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFoo.html">Foo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loan a contiguous buffer to this sequence. 
<p>
This operation changes the <code>owned</code> flag of the sequence to <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> and also sets the underlying buffer used by the sequence. See the user's manual for more information about sequences and memory ownership. <p>
Use this method if you want to manage the memory used by the sequence yourself. You must provide an array of elements and integers indicating how many elements are allocated in that array (i.e. the maximum) and how many elements are valid (i.e. the length). The sequence will subsequently use the memory you provide and will not permit it to be freed by a call to ::FooSeq::maximum(long). <p>
Once you have loaned a buffer to a sequence, make sure that you don't free it before calling <a class="el" href="structFooSeq.html#a13">FooSeq::unloan</a>: the next time you access the sequence, you will be accessing freed memory! <p>
You can use this method to wrap stack memory with a sequence interface, thereby avoiding dynamic memory allocation. Create a <a class="el" href="structFooSeq.html">FooSeq</a> and an array of type <a class="el" href="structFoo.html">Foo</a> and then loan the array to the sequence: <p>
<div class="fragment"><pre class="fragment"> ::Foo fooArray[10];<a class="code" href="structFooSeq.html#a20"></a>
<a class="code" href="structFooSeq.html#a20">  ::FooSeq</a> fooSeq;
                             fooSeq.loan_contiguous(fooArray, 0, 10); 
</pre></div> <p>
By default, a sequence you create owns its memory unless you explicitly loan memory of your own to it. In a very few cases, RTI Data Distribution Service will return a sequence to you that has a loan; those cases are documented as such. For example, if you call <a class="el" href="classFooDataReader.html#a0">FooDataReader::read</a> or <a class="el" href="classFooDataReader.html#a1">FooDataReader::take</a> and pass in sequences with no loan and no memory allocated, RTI Data Distribution Service will loan memory to your sequences which must be unloaned with <a class="el" href="classFooDataReader.html#a12">FooDataReader::return_loan</a>. See the documentation of those methods for more information. <p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="structFooSeq.html#a9">FooSeq::maximum()</a> == 0; i.e. the sequence has no memory allocated to it. <p>
<a class="el" href="structFooSeq.html#a18">FooSeq::has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>; i.e. the sequence does not already have an outstanding loan </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>The sequence will store its elements in the buffer provided. <p>
<a class="el" href="structFooSeq.html#a18">FooSeq::has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> <p>
<a class="el" href="structFooSeq.html#a6">FooSeq::length()</a> == new_length <p>
<a class="el" href="structFooSeq.html#a9">FooSeq::maximum()</a> == new_max </dd></dl>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type <a class="el" href="structFoo.html">Foo</a>. It may be NULL if new_max == 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_length</em>&nbsp;</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if <code>buffer</code> is successfully loaned to this sequence or <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. Failure only occurs due to failing to meet the pre-conditions. Upon failure the sequence remains unmodified. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structFooSeq.html#a13">FooSeq::unloan</a>, <a class="el" href="structFooSeq.html#a12">FooSeq::loan_discontiguous</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="FooSeq::loan_discontiguous"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::loan_discontiguous           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structFoo.html">Foo</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loan a discontiguous buffer to this sequence. 
<p>
This method is exactly like <a class="el" href="structFooSeq.html#a11">FooSeq::loan_contiguous</a> except that the buffer loaned is an array of <a class="el" href="structFoo.html">Foo</a> pointers, not an array of <a class="el" href="structFoo.html">Foo</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type Foo*. It may be NULL if new_max == 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_length</em>&nbsp;</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structFooSeq.html#a13">FooSeq::unloan</a>, <a class="el" href="structFooSeq.html#a11">FooSeq::loan_contiguous</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="FooSeq::unloan"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::unloan           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the loaned buffer in the sequence and set the maximum to 0. 
<p>
This method affects only the state of this sequence; it does not change the contents of the buffer in any way. <p>
Only the user who originally loaned a buffer should return that loan, as the user may have dependencies on that memory known only to them. Unloaning someone else's buffer may cause unspecified problems. For example, suppose a sequence is loaning memory from a custom memory pool. A user of the sequence likely has no way to release the memory back into the pool, so unloaning the sequence buffer would result in a resource leak. If the user were to then re-loan a different buffer, the original creator of the sequence would have no way to discover, when freeing the sequence, that the loan no longer referred to its own memory and would thus not free the user's memory properly, exacerbating the situation and leading to undefined behavior. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> <p>
maximum == 0 </dd></dl>
<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the preconditions were met. Otherwise <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. The function only fails if the pre-conditions are not met, in which case it leaves the sequence unmodified. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structFooSeq.html#a11">FooSeq::loan_contiguous</a>, <a class="el" href="structFooSeq.html#a12">FooSeq::loan_discontiguous</a>, ::FooSeq::maximum(long) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="FooSeq::has_ownership"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool FooSeq::has_ownership           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the value of the owned flag. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if sequence owns the underlying buffer, or <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> if it has an outstanding loan. </dd></dl>
    </td>
  </tr>
</table>
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Data Distribution Service C++ API Version 4.2e (General Access Release)</A>
Copyright &copy; 4 Dec 2007 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
