<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTI Data Distribution Service C API: DDS_DataReaderResourceLimitsQosPolicy Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>DDS_DataReaderResourceLimitsQosPolicy Struct Reference<br>
<small>
[<a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html">DATA_READER_RESOURCE_LIMITS</a>]</small>
</h1>Resource limits that apply only to <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> instances.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o0">max_remote_writers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read, including all instances.  <a href="#o0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o1">max_remote_writers_per_instance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read a single instance.  <a href="#o1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o2">max_samples_per_remote_writer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of out-of-order samples from a given remote <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a> that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a>.  <a href="#o2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o3">max_infos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of info units that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> can use to store <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>.  <a href="#o3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o4">initial_remote_writers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read, including all instances.  <a href="#o4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o5">initial_remote_writers_per_instance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read a single instance.  <a href="#o5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o6">initial_infos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initial number of info units that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> can have, which are used to store <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>.  <a href="#o6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o7">initial_outstanding_reads</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initial number of outstanding reads that have not call finish yet on the same <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#o7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o8">max_outstanding_reads</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of outstanding reads that have not called finish yet on the same <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#o8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o9">max_samples_per_read</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of samples that can be read/taken on a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>.  <a href="#o9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">disable_fragmentation_support</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> can receive fragmented samples.  <a href="#o10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o11">max_fragmented_samples</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of samples for which the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments at a given point in time.  <a href="#o11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o12">initial_fragmented_samples</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initial number of samples for which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments.  <a href="#o12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o13">max_fragmented_samples_per_remote_writer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of samples per remote writer for which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments.  <a href="#o13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o14">max_fragments_per_sample</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of fragments for a single sample.  <a href="#o14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o15">dynamically_allocate_fragmented_samples</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> pre-allocates storage for storing fragmented samples.  <a href="#o15"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Resource limits that apply only to <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> instances. 
<p>
This QoS policy is an extension to the DDS standard. <p>
<dl compact><dt><b>Entity:</b></dt><dd><a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> </dd></dl>
<dl compact><dt><b>Properties:</b></dt><dd><a class="el" href="group__DDSQosTypesModule.html#a_prop_rxo">RxO</a> = N/A <br>
 <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable">Changeable</a> = <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable_no">NO</a> <br>
 </dd></dl>

<p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="o0" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o0">DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read, including all instances. 
<p>
<b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> <br>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a><br>
, &gt;= initial_remote_writers<br>
 &gt;= max_remote_writers_per_instance <p>
For unkeyed types this value has to be equal to max_remote_writers_per_instance.<br>
 <p>
Note: For efficiency, set <code>max_remote_writers</code> &gt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o1">DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance</a>.     </td>
  </tr>
</table>
<a class="anchor" name="o1" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o1">DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read a single instance. 
<p>
<b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> <br>
 <p>
<b>[range]</b> [1, 1024] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a>, &lt;= max_remote_writers, &gt;= initial_remote_writers_per_instance <p>
For unkeyed types this value has to be equal to max_remote_writers.<br>
 <p>
Note: For efficiency, set <code>max_remote_writers_per_instance</code> &lt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o0">DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers</a>     </td>
  </tr>
</table>
<a class="anchor" name="o2" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_remote_writer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o2">DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_remote_writer</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of out-of-order samples from a given remote <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a> that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a>. 
<p>
<b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> <p>
<b>[range]</b> [1, 100 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a>, &lt;= <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#o0">DDS_ResourceLimitsQosPolicy::max_samples</a>     </td>
  </tr>
</table>
<a class="anchor" name="o3" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_infos"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o3">DDS_DataReaderResourceLimitsQosPolicy::max_infos</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of info units that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> can use to store <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>. 
<p>
When read/take is called on a data reader, the data reader passes a sequence of data samples and an associated sample info sequence. The sample info sequence contains additional information for each data sample. <p>
max_infos determines the resources allocated for storing sample info. This memory is loaned to the application when passing a sample info sequence. <p>
Note that sample info is a snapshot, generated when read/take is called. <p>
max_infos should not be less than max_samples. <p>
<b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> <p>
<b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_infos     </td>
  </tr>
</table>
<a class="anchor" name="o4" doxytag="DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o4">DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read, including all instances. 
<p>
<b>[default]</b> 2<br>
 <p>
<b>[range]</b> [1, 1 million], &lt;= max_remote_writers<br>
 <p>
For unkeyed types this value has to be equal to initial_remote_writers_per_instance.<br>
 <p>
Note: For efficiency, set initial_remote_writers &gt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o5">DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance</a>.     </td>
  </tr>
</table>
<a class="anchor" name="o5" doxytag="DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o5">DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may read a single instance. 
<p>
<b>[default]</b> 2<br>
 <p>
<b>[range]</b> [1,1024], &lt;= max_remote_writers_per_instance<br>
 <p>
For unkeyed types this value has to be equal to initial_remote_writers.<br>
 <p>
Note: For efficiency, set initial_remote_writers_per_instance &lt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o4">DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers</a>.     </td>
  </tr>
</table>
<a class="anchor" name="o6" doxytag="DDS_DataReaderResourceLimitsQosPolicy::initial_infos"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o6">DDS_DataReaderResourceLimitsQosPolicy::initial_infos</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The initial number of info units that a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> can have, which are used to store <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a>. 
<p>
<b>[default]</b> 32 <p>
<b>[range]</b> [1,1 million], &lt;= max_infos     </td>
  </tr>
</table>
<a class="anchor" name="o7" doxytag="DDS_DataReaderResourceLimitsQosPolicy::initial_outstanding_reads"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o7">DDS_DataReaderResourceLimitsQosPolicy::initial_outstanding_reads</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The initial number of outstanding reads that have not call finish yet on the same <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
<b>[default]</b> 2 <p>
<b>[range]</b> [1,1024], &lt;= max_outstanding_reads     </td>
  </tr>
</table>
<a class="anchor" name="o8" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_outstanding_reads"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o8">DDS_DataReaderResourceLimitsQosPolicy::max_outstanding_reads</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of outstanding reads that have not called finish yet on the same <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
<b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a> <p>
<b>[range]</b> [1, 1024] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a>, &lt;= initial_outstanding_reads     </td>
  </tr>
</table>
<a class="anchor" name="o9" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_read"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o9">DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_read</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maximum number of samples that can be read/taken on a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a>. 
<p>
<b>[default]</b> 1024 <p>
<b>[range]</b> [1,1024]     </td>
  </tr>
</table>
<a class="anchor" name="o10" doxytag="DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines whether the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> can receive fragmented samples. 
<p>
When fragmentation support is not needed, disabling fragmentation support will save some memory resources. <p>
<b>[default]</b> <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>     </td>
  </tr>
</table>
<a class="anchor" name="o11" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o11">DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of samples for which the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments at a given point in time. 
<p>
At any given time, a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments for up to <code>max_fragmented_samples</code> samples while waiting for the remaining fragments. These samples need not have consecutive sequence numbers and may have been sent by different <a class="el" href="group__DDSWriterModule.html#ga0">DDS_DataWriter</a> instances. <p>
Once all fragments of a sample have been received, the sample is treated as a regular sample and becomes subject to standard QoS settings such as <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#o0">DDS_ResourceLimitsQosPolicy::max_samples</a>. <p>
The middleware will drop fragments if the <code>max_fragmented_samples</code> limit has been reached. For best-effort communication, the middleware will accept a fragment for a new sample, but drop the oldest fragmented sample from the same remote writer. For reliable communication, the middleware will drop fragments for any new samples until all fragments for at least one older sample from that writer have been received. <p>
Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. <p>
<b>[default]</b> 1024 <p>
<b>[range]</b> [1, 1 million]     </td>
  </tr>
</table>
<a class="anchor" name="o12" doxytag="DDS_DataReaderResourceLimitsQosPolicy::initial_fragmented_samples"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o12">DDS_DataReaderResourceLimitsQosPolicy::initial_fragmented_samples</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The initial number of samples for which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments. 
<p>
Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. <p>
<b>[default]</b> 4 <p>
<b>[range]</b> [1,1024], &lt;= max_fragmented_samples     </td>
  </tr>
</table>
<a class="anchor" name="o13" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples_per_remote_writer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o13">DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples_per_remote_writer</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The maximum number of samples per remote writer for which a <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> may store fragments. 
<p>
Logical limit so a single remote writer cannot consume all available resources. <p>
Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. <p>
<b>[default]</b> 256 <p>
<b>[range]</b> [1, 1 million], &lt;= max_fragmented_samples     </td>
  </tr>
</table>
<a class="anchor" name="o14" doxytag="DDS_DataReaderResourceLimitsQosPolicy::max_fragments_per_sample"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o14">DDS_DataReaderResourceLimitsQosPolicy::max_fragments_per_sample</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maximum number of fragments for a single sample. 
<p>
Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. <p>
<b>[default]</b> 512 <p>
<b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga1">DDS_LENGTH_UNLIMITED</a>     </td>
  </tr>
</table>
<a class="anchor" name="o15" doxytag="DDS_DataReaderResourceLimitsQosPolicy::dynamically_allocate_fragmented_samples"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o15">DDS_DataReaderResourceLimitsQosPolicy::dynamically_allocate_fragmented_samples</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines whether the <a class="el" href="group__DDSReaderModule.html#ga0">DDS_DataReader</a> pre-allocates storage for storing fragmented samples. 
<p>
By default, the middleware will allocate memory upfront for storing fragments for up to <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o12">DDS_DataReaderResourceLimitsQosPolicy::initial_fragmented_samples</a> samples. This memory may grow up to <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o11">DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples</a> if needed. <p>
If <code>dynamically_allocate_fragmented_samples</code> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>, the middleware does not allocate memory upfront, but instead allocates memory from the heap upon receiving the first fragment of a new sample. The amount of memory allocated equals the amount of memory needed to store all fragments in the sample. Once all fragments of a sample have been received, the sample is deserialized and stored in the regular receive queue. At that time, the dynamically allocated memory is freed again. <p>
This QoS setting may be useful for large, but variable-sized data types where upfront memory allocation for multiple samples based on the maximum possible sample size may be expensive. The main disadvantage of not pre-allocating memory is that one can no longer guarantee the middleware will have sufficient resources at run-time. <p>
Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#o10">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. <p>
<b>[default]</b> <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>     </td>
  </tr>
</table>
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Data Distribution Service C API Version 4.2e (General Access Release)</A>
Copyright &copy; 4 Dec 2007 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
