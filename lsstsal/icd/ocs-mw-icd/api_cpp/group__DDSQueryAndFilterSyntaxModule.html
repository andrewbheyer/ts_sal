<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTI Data Distribution Service C++ API: Queries and Filters Syntax</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>Queries and Filters Syntax<br>
<small>
[<a class="el" href="group__DDSDcpsModule.html">DDS API Reference</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<h2><a class="anchor" name="query_and_filter_syntax">
Syntax for DDS Queries and Filters</a></h2>
A subset of SQL syntax is used in several parts of the specification:<p>
<ul>
<li>The <code>filter_expression</code> in the <a class="el" href="classDDSContentFilteredTopic.html">DDSContentFilteredTopic</a> </li>
<li>The <code>query_expression</code> in the <a class="el" href="classDDSQueryCondition.html">DDSQueryCondition</a> </li>
<li>The <code>topic_expression</code> in the <a class="el" href="classDDSMultiTopic.html">DDSMultiTopic</a></li>
</ul>
Those expressions may use a subset of SQL, extended with the possibility to use program variables in the SQL expression. The allowed SQL expressions are defined with the BNF-grammar below.<p>
The following notational conventions are made: <ul>
<li><em>NonTerminals</em> are typeset in italics. </li>
<li><code>'Terminals'</code> are quoted and typeset in a fixed width font. They are written in upper case in most cases in the BNF-grammar below, but should be case insensitive. </li>
<li><b>TOKENS</b> are typeset in bold. </li>
<li>The notation (<em>element</em> // ',') represents a non-empty comma-separated list of <em>elements</em>.</li>
</ul>
<h2><a class="anchor" name="sql_grammar_in_BNF">
SQL grammar in BNF</a></h2>
<pre>
<em>Expression</em> ::= <em>FilterExpression</em>
           |   <em>TopicExpression</em>
           |   <em>QueryExpression</em>
           <b>.</b> 
<em>FilterExpression</em> ::= <em>Condition</em>
<em>TopicExpression</em>  ::= <em>SelectFrom</em> { <em>Where</em> } ';'
<em>QueryExpression</em>  ::= { <em>Condition</em> }{ <code>'ORDER BY'</code> (<b>FIELDNAME</b> // ',') }
                     <b>.</b></pre><p>
<pre><em>SelectFrom</em>       ::= <code>'SELECT'</code> <em>Aggregation</em> <code>'FROM'</code> <em>Selection</em>
                 <b>.</b>
<em>Aggregation</em>      ::= <code>'*'</code>
                 |   (<em>SubjectFieldSpec</em> // ',')
                 <b>.</b>
<em>SubjectFieldSpec</em> ::= <b>FIELDNAME</b>
                 |   <b>FIELDNAME</b> <code>'AS'</code> <b>IDENTIFIER</b>
                 |   <b>FIELDNAME</b> <b>IDENTIFIER</b>
                 <b>.</b>
<em>Selection</em>   ::= <b>TOPICNAME</b>
            |   <b>TOPICNAME</b> <em>NaturalJoin</em> <em>JoinItem</em>
            <b>.</b>
<em>JoinItem</em>    ::= <b>TOPICNAME</b>
            |   <b>TOPICNAME</b> <em>NaturalJoin</em> <em>JoinItem</em>
            |   <code>'('</code> <b>TOPICNAME</b> <em>NaturalJoin</em> <em>JoinItem</em> <code>')'</code>
            <b>.</b>
<em>NaturalJoin</em> ::= <code>'INNER JOIN'</code>
            |   <code>'INNER NATURAL JOIN'</code>
            |   <code>'NATURAL JOIN'</code>
            |   <code>'NATURAL INNER JOIN'</code>
            <b>.</b>
<em>Where</em>       ::= <code>'WHERE'</code> <em>Condition</em>
            <b>.</b>
<em>Condition</em>   ::= <em>Predicate</em>
            |   <em>Condition</em> <code>'AND'</code> <em>Condition</em>
            |   <em>Condition</em> <code>'OR'</code> <em>Condition</em>
            |   <code>'NOT'</code> <em>Condition</em>
            |   <code>'('</code> <em>Condition</em> <code>')'</code>
            <b>.</b>
<em>Predicate</em>   ::= <em>ComparisonPredicate</em>
            |   <em>BetweenPredicate</em>
            <b>.</b>
<em>ComparisonPredicate</em> ::= <em>ComparisonTerm</em> <em>RelOp</em> <em>ComparisonTerm</em>
                    <b>.</b>
<em>ComparisonTerm</em>      ::= <b>FieldIdentifier</b>
                    | <em>Parameter</em>
                    <b>.</b>
<em>BetweenPredicate</em>    ::= <em>FieldIdentifier</em> <code>'BETWEEN'</code> <em>Range</em>
                    |   <em>FieldIdentifier</em> <code>'NOT BETWEEN'</code> <em>Range</em>
                    <b>.</b>
<em>FieldIdentifier</em>      ::= <b>FIELDNAME</b>
                    | <b>IDENTIFIER</b>
                    <b>.</b>
<em>RelOp</em>     ::= <code>'='</code> | <code>'&gt;'</code> | <code>'&gt;='</code> | <code>'&lt;'</code> | <code>'&lt;='</code> | <code>'&lt;&gt;'</code> | <code>'LIKE'</code>
          <b>.</b>
<em>Range</em>     ::= <em>Parameter</em> <code>'AND'</code> <em>Parameter</em>
          <b>.</b>
<em>Parameter</em> ::= <b>INTEGERVALUE</b>
          |   <b>CHARVALUE</b>
          |   <b>FLOATVALUE</b>
          |   <b>STRING</b>
          |   <b>ENUMERATEDVALUE</b>
          |   <b>BOOLEANVALUE</b>
          |   <b>PARAMETER</b>
          <b>.</b>
</pre><p>
<b>Note</b> -- INNER JOIN, INNER NATURAL JOIN, NATURAL JOIN, and NATURAL INNER JOIN are all aliases, in the sense that they have the same semantics. They are all supported because they all are part of the SQL standard.<h2><a class="anchor" name="token_expression">
Token expression</a></h2>
The syntax and meaning of the tokens used in the SQL grammar is described as follows:<p>
<ul>
<li><b>IDENTIFIER</b> - An identifier for a FIELDNAME, and is defined as any series of characters 'a', ..., 'z', 'A', ..., 'Z', '0', ..., '9', '_' but may not start with a digit.</li>
</ul>
Formal notation: <pre>
      IDENTIFIER: <em>LETTER</em> (<em>PART_LETTER</em>)*
      where <em>LETTER</em>: [ "A"-"Z","_","a"-"z" ]
            <em>PART_LETTER</em>: [ "A"-"Z","_","a"-"z","0"-"9" ]
      </pre><p>
<ul>
<li><b>FIELDNAME</b> - A fieldname is a reference to a field in the data-structure. The dot '.' is used to navigate through nested structures. The number of dots that may be used in a FIELDNAME is unlimited. The FIELDNAME can refer to fields at any depth in the data structure. The names of the field are those specified in the IDL definition of the corresponding structure, which may or may not match the fieldnames that appear on the language-specific (e.g., C/C++, Java) mapping of the structure. To reference to the <em>n</em>+1 element in an array or sequence, use the notation '[<em>n</em>]', where <em>n</em> is a natural number (zero included). FIELDNAME must resolve to a primitive IDL type; that is either boolean, octet, (unsigned) short, (unsigned) long, (unsigned) long long, float double, char, wchar, string, wstring, or enum.</li>
</ul>
Formal notation: <pre>
      FIELDNAME: <em>FieldNamePart</em> ( "." <em>FieldNamePart</em> )*
      where <em>FieldNamePart</em> : <b>IDENTIFIER</b> ( "[" <em>Index</em> "]" )*
            <em>Index&gt;</em> : (["0"-"9"])+
                   | ["0x","0X"](["0"-"9", "A"-"F", "a"-"f"])+
      </pre><p>
Primitive IDL types referenced by FIELDNAME are treated as different types in <em>Predicate</em> according to the following table:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Predicate Data Type</b> </td><td><b>IDL Type</b>  </td></tr>
<tr>
<td>BOOLEANVALUE </td><td>boolean  </td></tr>
<tr>
<td>INTEGERVALUE </td><td>octet, (unsigned) short, (unsigned) long, (unsigned) long long   </td></tr>
<tr>
<td>FLOATVALUE </td><td>float, double  </td></tr>
<tr>
<td>CHARVALUE </td><td>char, wchar  </td></tr>
<tr>
<td>STRING </td><td>string, wstring  </td></tr>
<tr>
<td>ENUMERATEDVALUE </td><td>enum  </td></tr>
</table>
<p>
<ul>
<li><b>TOPICNAME</b> - A topic name is an identifier for a topic, and is defined as any series of characters 'a', ..., 'z', 'A', ..., 'Z', '0', ..., '9', '_' but may not start with a digit.</li>
</ul>
Formal notation: <pre>
       TOPICNAME : <b>IDENTIFIER</b>
       </pre><p>
<ul>
<li><b>INTEGERVALUE</b> - Any series of digits, optionally preceded by a plus or minus sign, representing a decimal integer value within the range of the system. A hexadecimal number is preceded by 0x and must be a valid hexadecimal expression.</li>
</ul>
Formal notation: <pre>
       INTEGERVALUE : (["+","-"])? (["0"-"9"])+ [("L","l")]?
                    | (["+","-"])? ["0x","0X"](["0"-"9", "A"-"F", "a"-"f"])+ [("L","l")]?
       </pre><p>
<ul>
<li><b>CHARVALUE</b> - A single character enclosed between single quotes.</li>
</ul>
Formal notation: <pre>
      CHARVALUE : "'" (~["'"])? "'"
      </pre><p>
<ul>
<li><b>FLOATVALUE</b> - Any series of digits, optionally preceded by a plus or minus sign and optionally including a floating point ('.'). A power-of-ten expression may be postfixed, which has the syntax e<em>n</em> or E<em>n</em>, where <em>n</em> is a number, optionally preceded by a plus or minus sign.</li>
</ul>
Formal notation: <pre>
      FLOATVALUE : (["+","-"])? (["0"-"9"])* (".")? (["0"-"9"])+ (<em>EXPONENT</em>)?
      where <em>EXPONENT</em>: ["e","E"] (["+","-"])? (["0"-"9"])+
      </pre><p>
<ul>
<li><b>STRING</b> - Any series of characters encapsulated in single quotes, except the single quote itself.</li>
</ul>
Formal notation: <pre>
      STRING : "'" (~["'"])* "'"
      </pre><p>
<ul>
<li><b>ENUMERATEDVALUE</b> - An enumerated value is a reference to a value declared within an enumeration. Enumerated values consist of the name of the enumeration label enclosed in single quotes. The name used for the enumeration label must correspond to the label names specified in the IDL definition of the enumeration.</li>
</ul>
Formal notation: <pre>
      ENUMERATEDVALUE : "'" (~["'"])* "'"
      </pre><p>
<ul>
<li><b>BOOLEANVALUE</b> - Can either be 'TRUE' or 'FALSE', case insensitive.</li>
</ul>
Formal notation (case insensitive): <pre>
      BOOLEANVALUE : ["TRUE","FALSE"]
      </pre><p>
<ul>
<li><b>PARAMETER</b> - A parameter is of the form %<em>n</em>, where <em>n</em> represents a natural number (zero included) smaller than 100. It refers to the n + 1 <sup>th</sup> argument in the given context. Argument can only in primitive type value format. It cannot be a FIELDNAME.</li>
</ul>
Formal notation: <pre>
      PARAMETER : "%" (["0"-"9"])+
      </pre><h2><a class="anchor" name="type_compatibility">
Type compatability in Predicate</a></h2>
Only certain combination of type comparisons are valid in <em>Predicate</em>. The following table marked all the compatible pairs with 'YES':<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td></td><td><b>BOOLEANVALUE</b> </td><td><b>INTEGERVALUE</b> </td><td><b>FLOATVALUE</b> </td><td><b>CHARVALUE</b> </td><td><b>STRING</b> </td><td><b>ENUMERATEDVALUE</b>  </td></tr>
<tr>
<td><b>BOOLEAN</b> </td><td>YES </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><b>INTEGERVALUE</b> </td><td></td><td>YES </td><td>YES </td><td></td><td></td><td></td></tr>
<tr>
<td><b>FLOATVALUE</b> </td><td></td><td>YES </td><td>YES </td><td></td><td></td><td></td></tr>
<tr>
<td><b>CHARVALUE</b> </td><td></td><td></td><td></td><td>YES </td><td>YES </td><td>YES  </td></tr>
<tr>
<td><b>STRING</b> </td><td></td><td></td><td></td><td>YES </td><td>YES </td><td>YES  </td></tr>
<tr>
<td><b>ENUMERATEDVALUE</b> </td><td></td><td>YES </td><td></td><td>YES(*1) </td><td>YES(*1) </td><td>YES(*2)  </td></tr>
</table>
<p>
<ul>
<li>(*1) Because the formal notation of the Enumeration values, they are compatible with string and char literals, but they are not compatible with string or char variables, i.e., "MyEnum='EnumValue'" would be correct, but "MyEnum=MyString" is not allowed. </li>
<li>(*2) Only for same type Enums.</li>
</ul>
<h2><a class="anchor" name="query_and_filter_example">
Examples</a></h2>
Assuming Topic "Location" has as an associated type a structure with fields "flight_id, x, y, z", and Topic "FlightPlan" has as fields "flight_id, source, destination". The following are examples of using these expressions.<p>
Example of a <b>filter_expression</b> (for <a class="el" href="classDDSContentFilteredTopic.html">DDSContentFilteredTopic</a>) or a <b>query_expression</b> (for <a class="el" href="classDDSQueryCondition.html">DDSQueryCondition</a>):<p>
<ul>
<li><pre> "z &lt; 1000 AND x &lt;23" </pre></li>
</ul>
Example of a <b>topic_expression</b> (for <a class="el" href="classDDSMultiTopic.html">DDSMultiTopic</a> [<b>Not supported (optional)</b>]):<p>
<ul>
<li><pre> "SELECT flight_id, x, y, z AS height FROM 'Location' NATURAL JOIN
       'FlightPlan' WHERE height &lt; 1000 AND x &lt;23" </pre> </li>
</ul>
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Data Distribution Service C++ API Version 4.2e (General Access Release)</A>
Copyright &copy; 4 Dec 2007 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
