<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTI Data Distribution Service C API: rtiddsgen</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>rtiddsgen<br>
<small>
[<a class="el" href="group__DDSToolModule.html">Programming Tools</a>]</small>
</h1>Generates source code from IDL data types.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
Generates code necessary to allocate, send, receive, and print user-defined data types.<p>
<b> Usage </b><p>
<pre>
  <b>rtiddsgen</b> [-d &lt;outdir&gt;] 
        [-language &lt;C|C++|java&gt;]
        [-namespace (C++ only)]
        [-package &lt;packagePrefix&gt; (Java only)]
        [-example &lt;arch&gt;] 
        [-replace] 
        [-debug]
        [-corba &lt;client header file&gt;]
        [-optimization &lt;level of optimization&gt;]
        [-stringSize &lt;Unbounded strings size&gt;]
        [-sequenceSize &lt;Unbounded sequences size&gt;]
        [-notypecode]
        [-xml]
        [-ppDisable]
        [-ppPath &lt;path to the preprocessor&gt;]
        [-ppOption &lt;option&gt;]
        [-D &lt;name&gt;[=&lt;value&gt;]]
        [-U &lt;name&gt;]
        [-I &lt;directory&gt;]
        [-version]
        [-help] 
        IDLFile.idl</pre><p>
<pre></pre><p>
<b>-d</b> Specifies where to put the generated files. If omitted, the input IDLFile.idl's directory is used.<p>
<b>-language</b> Generates output for only the language specified. The default is C++.<p>
<b>-namespace</b> Specifies the use of C++ namespaces (for C++ only).<p>
<b>-package</b> Specifies a packagePrefix to use as the root package (for Java only).<p>
<b>-example</b> Generates example programs and makefiles (for UNIX-based systems) or workspace and project files (for Windows systems) based on the IDL file. The {arch} parameter specifies the architecture for the example makefiles. <p>
For -language C/C++, valid options for {arch} are: sparcSol2.8gcc3.2, sparcSol2.8cc5.2, sparcSol2.9gcc3.2, sparcSol2.9gcc3.3, sparcSol2.9cc5.3, sparcSol2.9cc5.4, sparcSol2.10gcc3.4.2, sparc64Sol2.10gcc3.4.2, sparc64Sol2.10cc5.8, i86Sol2.9gcc3.3.2, i86Sol2.10gcc3.4.4, x64Sol2.10gcc3.4.3, i86Linux2.4gcc3.2, i86Linux2.4gcc3.2.2, x64Linux2.4gcc3.2.3, i86Linux2.6gcc3.4.3, x64Linux2.6gcc3.4.5, i86Linux2.6gcc4.1.1, i86Suse9.5gcc3.3.3, x64Suse9.5gcc3.3.3, i86Suse10.1gcc4.1.0, x64Suse10.1gcc4.1.0, ppc7400Linux2.6gcc3.3.3, ppc7400Lynx4.0.0gcc3.2.2, ppc750Lynx4.0.0gcc3.2.2, ppc7400Lynx4.2.0gcc3.2.2, ppc750Lynx4.2.0gcc3.2.2, ppc7400Lynx4.2.0gcc3.4.3, i86Lynx4.0.0gcc2.95.3, i86Lynx4.0.0gcc3.2.2, i86Lynx4.2.0gcc3.2.2, i86LynxOS_SE3.0.0gcc3.4.3, i86QNX6.3.0qcc_cpp, i86QNX6.3.0qcc_acpp, ppc604Vx5.4gcc, pentiumVx5.5gcc, ppc405Vx5.5gcc, ppc604Vx5.5gcc, ppc603Vx5.5gcc, pentiumVx6.0gcc3.3.2, ppc604Vx6.0gcc3.3.2, pentiumVx6.0gcc3.3.2_rtp, ppc604Vx6.0gcc3.3.2_rtp, pentiumVx6.3gcc3.4.4, ppc604Vx6.3gcc3.4.4, pentiumVx6.3gcc3.4.4_rtp, ppc604Vx6.3gcc3.4.4_rtp, i86Win32VC60, i86Win32VC70, i86Win32VS2003, i86Win32VS2005, x64Win64VS2005, armv4WinCE5.0VS2005, i86WinCE5.0eVC40, ppc7400Inty5.0.4.mvme5100-7400, ppc7400Inty5.0.4.mvme5100-7400-ipk, ppc7400Inty5.0.9.mvme5100-7400-ghnet2<p>
For -language java, valid options for {arch} are: i86Win32jdk, x64Win64jdk, i86Sol2.9jdk, i86Sol2.10jdk, x64Sol2.10jdk, sparcSol2.8jdk, sparcSol2.9jdk, sparcSol2.10jdk, sparc64Sol2.10jdk, i86Linux2.4gcc3.2jdk, i86Linux2.4gcc3.2.2jdk, x64Linux2.4gcc3.2.3jdk, i86Linux2.6gcc3.4.3jdk, x64Linux2.6gcc3.4.5jdk, i86Linux2.6gcc4.1.1jdk, i86Suse9.5gcc3.3.3jdk, x64Suse9.5gcc3.3.3jdk, i86Suse10.1gcc4.1.0jdk, x64Suse10.1gcc4.1.0jdk, ppc7400Lynx4.0.0gcc3.2.2jdk, ppc750Lynx4.0.0gcc3.2.2jdk, ppc7400Lynx4.2.0gcc3.4.3jdk, i86Lynx4.0.0gcc2.95.3jdk, i86Lynx4.0.0gcc3.2.2jdk<p>
<b>-replace</b> Overwrites any existing output files. Warning: This removes any changes you may have made to the original files.<p>
<b>-debug</b> Generates intermediate files for debugging purposes.<p>
<b>-corba</b> Specifies the name of the header file for the IDL types generated by the CORBA IDL compiler. This file will be included in the rtiddsgen type header file instead of generating type definitions.<p>
CORBA support requires the RTI CORBA Compatibility Kit, an add-on product that provides a different version of rtiddsgen. Please contact <a href="mailto:support@rti.com">support@rti.com</a> for more information.<p>
<b>-optimization</b> Sets the optimization level. (Only applies to C/C++)<ul>
<li>0 (default): No optimization.</li><li>1: Compiler generates extra code for typedefs but optimizes its use. If the type that is used is a typedef that can be resolved either to a primitive type or to another type defined in the same file, the generated code will invoke the code of the most basic type to which the typedef can be resolved, unless the most basic type is an array or a sequence. This level can be used if the generated code is not expected to be modified.</li><li>2: Maximum optimization. Functionally the same as level 1, but extra code for typedef is not generated. This level can be used if the typedefs are only referred by types within the same file.</li></ul>
<p>
<b>-stringSize</b> Sets the size for unbounded strings. Default: 255 bytes.<p>
<b>-sequenceSize</b> Sets the size for unbounded sequences. Default: 100 elements.<p>
<b>-notypecode</b>: Disables the generation of type code information.<p>
<b>-xml</b>: Generates a XML representation of the IDL file.<p>
<b>-ppDisable</b>: Disables the preprocessor.<p>
<b>-ppNotRun</b>: Deprecated. Use -ppDisable instead.<p>
<b>-ppPath</b> &lt;path&gt;: Specifies the preprocessor path. The default value is "cpp" for non-Windows architectures, "cl.exe" for Windows architectures.<p>
<b>-ppOption</b> &lt;option&gt;: Specifies a preprocessor option.<p>
<b>-D</b> &lt;name&gt;[=&lt;value&gt;]: Defines preprocessor macros.<p>
<b>-U</b> &lt;name&gt;: Cancels any previous definition of name.<p>
<b>-I</b> &lt;directory&gt;: Adds the directory to the list of directories to be searched for header files.<p>
<b>-version</b>: Prints the version.<p>
<b>-help</b> Prints out this rtiddsgen usage help.<p>
<b>sourceIDLfile.idl</b> File containing IDL descriptions of your data types. Must have a .idl extension.<p>
<b> Description </b><p>
rtiddsgen takes a language-independent specification of the data format (IDL) and generates supporting classes and code to distribute instances of the data over RTI Data Distribution Service.<p>
To use rtiddsgen, you first write a description of your data types in IDL language.<p>
<b> C++ Example </b><p>
The following is an example generating the RTI Data Distribution Service type myDataType:<p>
<pre>
struct myDataType {
    long value;
};
</pre><p>
Assuming the name of the idl file is myFileName.idl then all you need to do is type:<p>
rtiddsgen myFileName.idl<p>
This generates myFileName.cxx, myFileName.h, myFileNamePlugin.cxx, myFileNamePlugin.h, myFileNameSupport.cxx and myFileNameSupport.h. By default, rtiddsgen will not overwrite these files. You must use the -replace argument to do that.<p>
rtiddsgen currently only generate code for types that do not have key support. If you need key support for your type, you will need to uncomment some code in myFilePlugin.cxx and replace the uncommented code with your own implementation.<p>
<b> IDL Language </b><p>
In the IDL language, data types are described in a fashion almost identical to structures in "C." The complete description of the language can be found at the OMG website.<p>
rtiddsgen does not support the full IDL language. Below are the IDL types that are currently supported:<p>
<ul>
<li>char </li>
<li>wchar </li>
<li>octet </li>
<li>short </li>
<li>unsigned short </li>
<li>long </li>
<li>unsigned long </li>
<li>long long </li>
<li>unsigned long long </li>
<li>float </li>
<li>double </li>
<li>long double </li>
<li>boolean </li>
<li>enum </li>
<li>constant </li>
<li>typedef </li>
<li>union </li>
<li>array of above types </li>
<li>array of sequences </li>
<li>bounded sequence of above types </li>
<li>unbounded sequence of above types </li>
<li>sequence of arrays </li>
<li>bounded string </li>
<li>unbounded string </li>
<li>bounded wstring </li>
<li>unbounded wstring</li>
</ul>
The following non-IDL types are also supported by rtiddsgen: <ul>
<li>bitfield </li>
<li>valued enum</li>
</ul>
<b> Use of Unsupported Types in an IDL File </b><p>
You may include unsupported data types in the IDL file. rtiddsgen does not consider this an error. This allows you to use types that are defined in non-IDL languages with either hand-written or non-rtiddsgen written plug-ins. For example, the following is allowable: <div class="fragment"><pre class="fragment"><span class="comment">//@copy #include "Bar.h"</span>
<span class="comment">//@copy #include "BarHandGeneratedPlugin.h"</span>
<span class="keyword">struct </span><a class="code" href="structFoo.html">Foo</a> {
<span class="keywordtype">short</span> height;
Bar barMember;
};
</pre></div><p>
In the above case, Bar is defined externally by the user.<p>
<b> Multiple Types in a Single File </b><p>
You can specify multiple types in a single idl file. This can simplify management of files in your distributed program.<p>
<b> Use of Directives in an IDL File </b><p>
The following directives can be used in your IDL file: Note: Do not put a space between the slashes and the @ sign. Note: Directives are case-sensitive (for example: use key, not Key).<p>
<ul>
<li>//@key The field declared just before this directive in the enclosing structure is part of the key. Any number of a structure's fields may be declared part of the key.</li>
</ul>
<ul>
<li>//@copy This copies a line of text into the generated code verbatim (for all languages). The text is copied into all of the type-specific files generated by rtiddsgen (except the examples). </li>
<li>//@copy-c Same as //@copy, but for C++/C-only code. </li>
<li>//@copy-java Same as //@copy, but for Java-only code.</li>
</ul>
<ul>
<li>//@copy-declaration This is like //@copy, but only copies the text into the file where the type is declared (&lt;type&gt;.h for C++/C, or &lt;type&gt;.java for Java). </li>
<li>//@copy-c-declaration Same as //@copy-declaration, but for C++/C-only code. </li>
<li>//@copy-java-declaration Same as //@copy-declaration, but for Java-only code.</li>
</ul>
<ul>
<li>//@resolve-name [true|false] This specifies whether or not rtiddsgen should resolve the scope of a type. If this directive is not present or set to true, rtiddsgen resolves the scope. Otherwise rtiddsgen delegates the resolution of a type to the user.</li>
</ul>
<ul>
<li>//@top-level [true|false] This specifies whether or not rtiddsgen should generate type-support code for a particular struct or union. The default is true.</li>
</ul>
<b> Using Generated Types Without RTI Data Distribution Service (Standalone) </b><p>
You can use the generated type-specific source and header files without linking the RTI Data Distribution Service libraries or even including the RTI Data Distribution Service header files. That is, the generated files for your data types can be used standalone.<p>
The directory &lt;NDDSHOME&gt;/resource/standalone contains the helper files required to work in standalone mode: <ul>
<li>include: header and templates files for C/C++. </li>
<li>src: source files for C/C++. </li>
<li>class: Java jar file.</li>
</ul>
<b>Using Standalone Types in C</b><p>
The generated files that can be used standalone are: <ul>
<li>&lt;idl file name&gt;.c : Types source file </li>
<li>&lt;idl file name&gt;.h : Types header file</li>
</ul>
You <em>cannot</em> use the type plug-in (&lt;idl file&gt;Plugin.c &lt;idl file&gt;Plugin.h) or the type support (&lt;idl file&gt;Support.c &lt;idl file&gt;Support.h) code standalone.<p>
To use the rtiddsgen-generated types in a standalone manner: <ul>
<li>
Include the directory &lt;NDDSHOME&gt;/resource/standalone/include in the list of directories to be searched for header files. </li>
<li>
Add the source files ndds_standalone_type.c and &lt;idl file name&gt;.c to your project. </li>
<li>
Include the file &lt;idl file name&gt;.h in the source files that will use the generated types in a standalone way. </li>
<li>
Compile the project using the two following preprocessor definitions: <ul>
<li>
NDDS_STANDALONE_TYPE </li>
<li>
The definition for your platform: RTI_VXWORKS, RTI_QNX, RTI_WIN32, RTI_INTY, RTI_LYNX or RTI_UNIX </li>
</ul>
</li>
</ul>
<p>
<b>Using Standalone Types in C++</b><p>
The generated files that can be used standalone are: <ul>
<li>&lt;idl file name&gt;.cxx : Types source file </li>
<li>&lt;idl file name&gt;.h : Types header file</li>
</ul>
You <em>cannot</em> use the type plugin (&lt;idl file&gt;Plugin.cxx &lt;idl file&gt;Plugin.h) or the type support (&lt;idl file&gt;Support.cxx &lt;idl file&gt;Support.h) code standalone.<p>
To use the generated types in a standalone manner: <ul>
<li>
Include the directory &lt;NDDSHOME&gt;/resource/standalone/include in the list of directories to be searched for header files. </li>
<li>
Add the source files ndds_standalone_type.cxx and &lt;idl file name&gt;.cxx to your project. </li>
<li>
Include the file &lt;idl file name&gt;.h in the source files that will use the generated types in a standalone way. </li>
<li>
Compile the project using the two following preprocessor definitions: <ul>
<li>
NDDS_STANDALONE_TYPE </li>
<li>
The definition for your platform: RTI_VXWORKS, RTI_QNX, RTI_WIN32, RTI_INTY, RTI_LYNX or RTI_UNIX </li>
</ul>
</li>
</ul>
<p>
<b>Standalone Types in Java</b><p>
The generated files that can be used standalone are: <ul>
<li>&lt;idl type&gt;.java </li>
<li>&lt;idl type&gt;Seq.java</li>
</ul>
You <em>cannot</em> use the type code (&lt;idl file&gt;TypeCode.java), the type support (&lt;idl type&gt;TypeSupport.java), the data reader (&lt;idl file&gt;DataReader.java) or the data writer code (&lt;idl file&gt;DataWriter.java) standalone.<p>
To use the generated types in a standalone manner: <ul>
<li>Include the file ndds_standalone_type.jar in the classpath of your project. </li>
<li>Compile the project using the standalone types files (&lt;idl type&gt;.java &lt;idl type&gt;Seq.java). </li>
</ul>
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Data Distribution Service C API Version 4.2e (General Access Release)</A>
Copyright &copy; 4 Dec 2007 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
