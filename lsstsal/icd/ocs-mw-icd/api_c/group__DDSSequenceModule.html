<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTI Data Distribution Service C API: Sequence Support</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>Sequence Support<br>
<small>
[<a class="el" href="group__DDSInfrastructureModule.html">Infrastructure Module</a>]</small>
</h1>Defines sequence interface and primitive data types sequences.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSBuiltinSequenceModule.html">Built-in Sequences</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines sequences of primitive data type. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html">FooSeq</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> IDL <code>sequence<code>&lt;<a class="el" href="structFoo.html">Foo</a>&gt;</code>,</code> a sequence of type <code><a class="el" href="structFoo.html">Foo</a></code>.  <a href="structFooSeq.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga17">DDS_SEQUENCE_INITIALIZER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An initializer for new sequence instances.  <a href="#ga17"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga0">FooSeq_initialize</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize sequence instances.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga1">FooSeq_get_maximum</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current maximum of the sequence.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga2">FooSeq_set_maximum</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize this sequence to a new desired maximum.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga3">FooSeq_get_length</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sequence length.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga4">FooSeq_set_length</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the length of this sequence.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga5">FooSeq_ensure_length</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> length, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sequence to the desired length, and resize the sequence if necessary.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFoo.html">Foo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga6">FooSeq_get</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <code>i-th</code> element of the sequence.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga7">FooSeq_get_reference</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the pointer to the <code>i-th</code> element of this sequence.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga8">FooSeq_copy_no_alloc</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, const struct <a class="el" href="structFooSeq.html">FooSeq</a> *src_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from another sequence, only if the destination sequence has enough capacity.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga9">FooSeq_copy</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, const struct <a class="el" href="structFooSeq.html">FooSeq</a> *src_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from another sequence, resizing the sequence if necessary.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga10">FooSeq_from_array</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, const <a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga11">FooSeq_to_array</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements to an array of elements. The original contents of the array (if any) are replaced.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga12">FooSeq_loan_contiguous</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="structFoo.html">Foo</a> *buffer, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loan a contiguous buffer to this sequence.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga13">FooSeq_loan_discontiguous</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="structFoo.html">Foo</a> **buffer, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> new_max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loan a discontiguous buffer to this sequence.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga14">FooSeq_unloan</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the loaned buffer in the sequence and set the maximum to 0.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga15">FooSeq_has_ownership</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of the owned flag.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga16">FooSeq_finalize</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate this sequence's buffer.  <a href="#ga16"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Defines sequence interface and primitive data types sequences. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga17" doxytag="sequence.ifc::DDS_SEQUENCE_INITIALIZER"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define DDS_SEQUENCE_INITIALIZER          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An initializer for new sequence instances. 
<p>
This constant will initialize a new sequence to a valid empty state. C language users should assign it to uninitialized sequence instances before using them, at the time they are declared, or use <a class="el" href="group__DDSSequenceModule.html#ga0">FooSeq_initialize</a> as an alternative function to initialize new sequences. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="HelloWorld__subscriber_8c-example.html#a36">HelloWorld_subscriber.c</a>.</dl>    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga0" doxytag="sequence.ifc::FooSeq_initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize sequence instances. 
<p>
Use this function to initialize new sequences to a valid emptu state. C users should initialize sequences before using them. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga17">DDS_SEQUENCE_INITIALIZER</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="sequence.ifc::FooSeq_get_maximum"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> FooSeq_get_maximum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current maximum of the sequence. 
<p>
The <code>maximum</code> of the sequence represents the maximum number of elements that the underlying buffer can hold. It does not represent the current number of elements. <p>
The <code>maximum</code> is a non-negative number. It is initialized when the sequence is first created and can only be changed by mean of the <a class="el" href="group__DDSSequenceModule.html#ga2">FooSeq_set_maximum</a> operation. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the current maximum of the sequence. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga3">FooSeq_get_length</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="sequence.ifc::FooSeq_set_maximum"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_set_maximum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resize this sequence to a new desired maximum. 
<p>
This operation does nothing if the new desired maximum matches the current maximum. <p>
If this sequence owns its buffer and the new maximum is not equal to the old maximum, then the existing buffer will be freed and re-allocated. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> <p>
length == MINIMUM(original length, new_max) </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>Must be &gt;= 0. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="sequence.ifc::FooSeq_get_length"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a> FooSeq_get_length           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the sequence length. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the length of the sequence </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="sequence.ifc::FooSeq_set_length"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_set_length           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the length of this sequence. 
<p>
This function does not allocate/deallocate memory. <p>
The new length must not exceed the maximum of this sequence as returned by the <a class="el" href="group__DDSSequenceModule.html#ga1">FooSeq_get_maximum</a> operation. (Note that, if necessary, the maximum of this sequence can be increased manually by using the <a class="el" href="group__DDSSequenceModule.html#ga2">FooSeq_set_maximum</a> operation.) <p>
The elements of the sequence are not modified by this operation. If the new length is larger than the original length, the new elements will be uninitialized; if the length is decreased, the old elements that are beyond the new length will physically remain in the sequence but will not be accessible. <p>
<dl compact><dt><b>Postcondition:</b></dt><dd>length = new_length. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_length</em>&nbsp;</td><td>the new desired length. This value must be non-negative and cannot exceed maximum of the sequence. In other words 0 &lt;= new_length &lt;= maximum </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> on sucess or <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="sequence.ifc::FooSeq_ensure_length"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_ensure_length           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the sequence to the desired length, and resize the sequence if necessary. 
<p>
If the current maximum is greater than the desired length, then sequence is not resized. <p>
Otherwise if this sequence owns its buffer, the sequence is resized to the new maximum by freeing and re-allocating the buffer. However, if the sequence does not own its buffer, this operation will fail. <p>
This function allows user to avoid unnecessary buffer re-allocation. <p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>length</code> &lt;= <code>max</code> <p>
owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if sequence needs to be resized </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>length == <code>length</code> <p>
maximum == <code>max</code> if resized </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The new length that should be set. Must be &gt;= 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> If sequence need to be resized, this is the maximum that should be set. <code>max</code> &gt;= <code>length</code> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="sequence.ifc::FooSeq_get"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structFoo.html">Foo</a> FooSeq_get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the <code>i-th</code> element of the sequence. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="group__DDSSequenceModule.html#ga3">FooSeq_get_length</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the <code>i-th</code> element </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="sequence.ifc::FooSeq_get_reference"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structFoo.html">Foo</a>* FooSeq_get_reference           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the pointer to the <code>i-th</code> element of this sequence. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="group__DDSSequenceModule.html#ga3">FooSeq_get_length</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the <code>i-th</code> element </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="sequence.ifc::FooSeq_copy_no_alloc"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_copy_no_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>src_seq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements from another sequence, only if the destination sequence has enough capacity. 
<p>
Fill the elements in this sequence by copying the corresponding elements in <code>src_seq</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>this::maximum &gt;= src_seq::length <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>this::length == src_seq::length <p>
this[i] == src_seq[i] for 0 &lt;= i &lt; target_seq::length <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the sequence was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>If the pre-conditions are not met, the operator will print a message to stdout and leave this sequence unchanged. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga9">FooSeq_copy</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="sequence.ifc::FooSeq_copy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structFooSeq.html">FooSeq</a>* FooSeq_copy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>src_seq</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements from another sequence, resizing the sequence if necessary. 
<p>
This function invokes <a class="el" href="group__DDSSequenceModule.html#ga8">FooSeq_copy_no_alloc</a> after ensuring that the sequence has enough capacity to hold the elements to be copied. <p>
<em>will</em> allocate memory if this::maximum &lt; src_seq::length. <p>
Therefore, to programatically detect the successful completion of the operator it is recommended that the application first sets the length of this sequence to zero, makes the assignment, and then checks that the length of this sequence matches that of src_seq. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_seq</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>self</code>, this sequence </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga8">FooSeq_copy_no_alloc</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="sequence.ifc::FooSeq_from_array"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_from_array           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="structFoo.html">Foo</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>array</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced. 
<p>
Fill the elements in this sequence by copying the corresponding elements in <code>array</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>this::length == <code>length</code> <p>
this[i] == array[i] for 0 &lt;= i &lt; <code>length</code> <p>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be copy elements from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The length of the array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the array was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>If the pre-conditions are not met, the function will print a message to stdout and leave this sequence unchanged. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="sequence.ifc::FooSeq_to_array"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_to_array           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFoo.html">Foo</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>array</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy elements to an array of elements. The original contents of the array (if any) are replaced. 
<p>
Copy the elements of this sequence to the corresponding elements in the array. The original contents of the array are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be filled with elements from this sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The number of elements to be copied. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the elements of the sequence were successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="sequence.ifc::FooSeq_loan_contiguous"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_loan_contiguous           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFoo.html">Foo</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loan a contiguous buffer to this sequence. 
<p>
This operation changes the <code>owned</code> flag of the sequence to <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> and also sets the underlying buffer used by the sequence. See the user's manual for more information about sequences and memory ownership. <p>
Use this function if you want to manage the memory used by the sequence yourself. You must provide an array of elements and integers indicating how many elements are allocated in that array (i.e. the maximum) and how many elements are valid (i.e. the length). The sequence will subsequently use the memory you provide and will not permit it to be freed by a call to <a class="el" href="group__DDSSequenceModule.html#ga2">FooSeq_set_maximum</a>. <p>
Once you have loaned a buffer to a sequence, make sure that you don't free it before calling <a class="el" href="group__DDSSequenceModule.html#ga14">FooSeq_unloan</a>: the next time you access the sequence, you will be accessing freed memory! <p>
You can use this function to wrap stack memory with a sequence interface, thereby avoiding dynamic memory allocation. Create a <a class="el" href="structFooSeq.html">FooSeq</a> and an array of type <a class="el" href="structFoo.html">Foo</a> and then loan the array to the sequence: <p>
<div class="fragment"><pre class="fragment"> struct ::Foo fooArray[10];
                              struct ::FooSeq fooSeq =<a class="code" href="group__DDSSequenceModule.html#ga17"> ::DDS_SEQUENCE_INITIALIZER</a>;<a class="code" href="group__DDSSequenceModule.html#ga12"> </a>
<a class="code" href="group__DDSSequenceModule.html#ga12">                              ::FooSeq_loan_contiguous</a>(&amp;fooSeq, fooArray, 0, 10); 
</pre></div> <p>
By default, a sequence you create owns its memory unless you explicitly loan memory of your own to it. In a very few cases, RTI Data Distribution Service will return a sequence to you that has a loan; those cases are documented as such. For example, if you call <a class="el" href="group__DDSReaderModule.html#ga10">FooDataReader_read</a> or <a class="el" href="group__DDSReaderModule.html#ga11">FooDataReader_take</a> and pass in sequences with no loan and no memory allocated, RTI Data Distribution Service will loan memory to your sequences which must be unloaned with <a class="el" href="group__DDSReaderModule.html#ga22">FooDataReader_return_loan</a>. See the documentation of those functions for more information. <p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga1">FooSeq_get_maximum</a> == 0; i.e. the sequence has no memory allocated to it. <p>
<a class="el" href="group__DDSSequenceModule.html#ga15">FooSeq_has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>; i.e. the sequence does not already have an outstanding loan </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>The sequence will store its elements in the buffer provided. <p>
<a class="el" href="group__DDSSequenceModule.html#ga15">FooSeq_has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> <p>
<a class="el" href="group__DDSSequenceModule.html#ga3">FooSeq_get_length</a> == new_length <p>
<a class="el" href="group__DDSSequenceModule.html#ga1">FooSeq_get_maximum</a> == new_max </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type <a class="el" href="structFoo.html">Foo</a>. It may be NULL if new_max == 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_length</em>&nbsp;</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if <code>buffer</code> is successfully loaned to this sequence or <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> otherwise. Failure only occurs due to failing to meet the pre-conditions. Upon failure the sequence remains unmodified. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga14">FooSeq_unloan</a>, <a class="el" href="group__DDSSequenceModule.html#ga13">FooSeq_loan_discontiguous</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="sequence.ifc::FooSeq_loan_discontiguous"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_loan_discontiguous           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structFoo.html">Foo</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__DDSCdrTypesModule.html#ga5">DDS_Long</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_max</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loan a discontiguous buffer to this sequence. 
<p>
This function is exactly like <a class="el" href="group__DDSSequenceModule.html#ga12">FooSeq_loan_contiguous</a> except that the buffer loaned is an array of <a class="el" href="structFoo.html">Foo</a> pointers, not an array of <a class="el" href="structFoo.html">Foo</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type Foo*. It may be NULL if new_max == 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_length</em>&nbsp;</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_max</em>&nbsp;</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga14">FooSeq_unloan</a>, <a class="el" href="group__DDSSequenceModule.html#ga12">FooSeq_loan_contiguous</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="sequence.ifc::FooSeq_unloan"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_unloan           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the loaned buffer in the sequence and set the maximum to 0. 
<p>
This function affects only the state of this sequence; it does not change the contents of the buffer in any way. <p>
Only the user who originally loaned a buffer should return that loan, as the user may have dependencies on that memory known only to them. Unloaning someone else's buffer may cause unspecified problems. For example, suppose a sequence is loaning memory from a custom memory pool. A user of the sequence likely has no way to release the memory back into the pool, so unloaning the sequence buffer would result in a resource leak. If the user were to then re-loan a different buffer, the original creator of the sequence would have no way to discover, when freeing the sequence, that the loan no longer referred to its own memory and would thus not free the user's memory properly, exacerbating the situation and leading to undefined behavior. <p>
<dl compact><dt><b>Precondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> <p>
maximum == 0 </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if the preconditions were met. Otherwise <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a>. The function only fails if the pre-conditions are not met, in which case it leaves the sequence unmodified. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga12">FooSeq_loan_contiguous</a>, <a class="el" href="group__DDSSequenceModule.html#ga13">FooSeq_loan_discontiguous</a>, <a class="el" href="group__DDSSequenceModule.html#ga2">FooSeq_set_maximum</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="sequence.ifc::FooSeq_has_ownership"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_has_ownership           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the value of the owned flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a> if sequence owns the underlying buffer, or <a class="el" href="group__DDSCdrTypesModule.html#ga15">DDS_BOOLEAN_FALSE</a> if it has an outstanding loan. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="sequence.ifc::FooSeq_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga12">DDS_Boolean</a> FooSeq_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocate this sequence's buffer. 
<p>
Note that this function deletes this sequence's <em>buffer</em>, not this sequence itself. To avoid memory leaks, it should be called even on sequences declared on the stack. And after it has been called on a sequence located in dynamic memory, it is still necessary to call free(). <p>
<dl compact><dt><b>Precondition:</b></dt><dd>(owned == <a class="el" href="group__DDSCdrTypesModule.html#ga14">DDS_BOOLEAN_TRUE</a>). If this precondition is not met, no memory will be freed and an error will be logged. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>maximum == 0 and the underlying buffer is freed. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__DDSSequenceModule.html#ga1">FooSeq_get_maximum</a>, <a class="el" href="group__DDSSequenceModule.html#ga14">FooSeq_unloan</a> </dd></dl>
    </td>
  </tr>
</table>
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Data Distribution Service C API Version 4.2e (General Access Release)</A>
Copyright &copy; 4 Dec 2007 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
